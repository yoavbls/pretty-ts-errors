{
  "1005": "应为“{0}”。",
  "1007": "分析器预期在此处找到与“{0}”标记匹配的“{1}”。",
  "1029": "“{0}”修饰符必须位于“{1}”修饰符之前。",
  "1030": "已看到“{0}”修饰符。",
  "1031": "“{0}”修饰符不能出现在此类型的类元素上。",
  "1040": "“{0}”修饰符不能在环境上下文中使用。",
  "1042": "“{0}”修饰符不能在此处使用。",
  "1044": "“{0}”修饰符不可出现在模块或命名空间元素上。",
  "1055": "类型“{0}”不是 ES5 中有效的异步函数返回类型，因为它不引用与 Promise 兼容的构造函数值。",
  "1064": "异步函数或方法的返回类型必须为全局 Promise<T> 类型。你是否是指写入 \"Promise<{0}>\"?",
  "1070": "“{0}”修饰符不可出现在类型成员上。",
  "1071": "“{0}”修饰符不可出现在索引签名上。",
  "1079": "“{0}”修饰符不能与导入声明一起使用。",
  "1089": "“{0}”修饰符不能出现在构造函数声明中。",
  "1090": "“{0}”修饰符不能出现在参数中。",
  "1097": "“{0}”列表不能为空。",
  "1100": "严格模式下“{0}”的使用无效。",
  "1111": "必须在封闭类中声明私有字段“{0}”。",
  "1114": "标签“{0}”重复。",
  "1121": "不允许使用八进制文字。请使用语法“{0}”。",
  "1149": "文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同。",
  "1155": "必须初始化“{0}”声明。",
  "1156": "“{0}”声明只能在块的内部声明。",
  "1192": "模块“{0}”没有默认导出。",
  "1205": "启用“{0}”时重新导出类型需要使用“导出类型”。",
  "1209": "新表达式中的可选链无效。是否要调用“{0}()”?",
  "1210": "类中包含的代码在 JavaScript 的严格模式下进行计算，该模式不允许以此方式使用“{0}”。有关详细信息，请参阅 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode。",
  "1212": "应为标识符。“{0}”在严格模式下是保留字。",
  "1213": "应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。",
  "1214": "应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。",
  "1215": "“{0}”的使用无效。模块自动处于严格模式。",
  "1223": "已指定“{0}”标记。",
  "1224": "签名“{0}”必须为类型谓词。",
  "1225": "找不到参数“{0}”。",
  "1226": "类型谓词“{0}”不可分配给“{1}”。",
  "1227": "参数“{0}”和参数“{1}”的位置不一样。",
  "1230": "类型谓词无法在绑定模式中引用元素“{0}”。",
  "1243": "“{0}”修饰符不能与“{1}”修饰符一起使用。",
  "1245": "方法“{0}”不能具有实现，因为它标记为抽象。",
  "1248": "类成员不可具有“{0}”关键字。",
  "1259": "模块 \"{0}\" 只能在使用 \"{1}\" 标志时进行默认导入",
  "1261": "已包含的文件名 \"{0}\" 仅大小写与文件名 \"{1}\" 不同。",
  "1262": "应为标识符。“{0}”是模块顶层的预留字。",
  "1267": "属性“{0}”不能具有初始化表达式，因为它标记为摘要。",
  "1269": "启用“{0}”时，不能对类型或仅类型命名空间使用“export import”。",
  "1270": "装饰器函数返回类型“{0}”不可分配到类型“{1}”。",
  "1271": "装饰器函数返回类型为“{0}”，但预期为“void”或“any”。",
  "1273": "“{0}”修饰符不能出现在类型参数上",
  "1274": "“{0}”修饰符只能出现在类、接口或类型别名的类型参数上",
  "1277": "“{0}”修饰符只能出现在函数、方法或类的类型参数上",
  "1278": "运行时将使用 {1} 个自变量调用修饰器，但修饰器需要 {0} 个。",
  "1279": "运行时将使用 {1} 个自变量调用修饰器，但修饰器至少需要 {0} 个。",
  "1280": "启用“{0}”时，全局脚本文件中不允许使用命名空间。如果此文件不是全局脚本，请将“moduleDetection”设置为“force”或添加空的“export {}”语句。",
  "1281": "启用“{1}”时，无法从没有限定的其他文件访问“{0}”。请改用“{2}”。",
  "1282": "启用“verbatimModuleSyntax”时，“export =”声明必须引用值，但“{0}”仅引用类型。",
  "1283": "启用“verbatimModuleSyntax”，但“{0}”解析为仅类型声明时，“export =”声明必须引用实际值。",
  "1284": "启用“verbatimModuleSyntax”时，“export default”必须引用一个值，但“{0}”只引用了一个类型。",
  "1285": "启用“verbatimModuleSyntax”，但“{0}”解析为仅类型声明时，“export default”必须引用实际值。",
  "1289": "“{0}”解析为仅类型声明，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用导入“{0}”的 \"import type\"。",
  "1290": "“{0}”解析为仅类型声明，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用 \"export type { {0} as default }\"。",
  "1291": "“{0}”解析为一个类型，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用导入“{0}”的 \"import type\"。",
  "1292": "“{0}”解析为一个类型，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用 \"export type { {0} as default }\"。",
  "1329": "“{0}”收到的参数过少，无法在此处充当修饰器。你是要先调用它，然后再写入 \"@{0}()\" 吗?",
  "1339": "模块“{0}”不引用值，但在此处用作值。",
  "1340": "模块 \"{0}\" 不引用类型，但在此处用作类型。你是想使用 \"typeof import('{0}')\" 吗?",
  "1359": "应为标识符。\"{0}\" 是保留字，不能在此处使用。",
  "1360": "类型“{0}”不满足预期类型“{1}”。",
  "1361": "\"{0}\" 是使用 \"import type\" 导入的，因此不能用作值。",
  "1362": "\"{0}\" 是使用 \"export type\" 导出的，因此不能用作值。",
  "1369": "你是想使用 \"{0}\" 吗?",
  "1376": "此处导入了 \"{0}\"。",
  "1377": "在此处导出了 \"{0}\"。",
  "1389": "“{0}”不得用作变量声明名称。",
  "1390": "不允许将 '{0}' 作为参数名。",
  "1393": "通过 {0} 从文件 \"{1}\" 导入",
  "1394": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入",
  "1395": "通过 {0} 从文件 \"{1}\" 导入，以按照 compilerOptions 中指定的配置导入 \"importHelpers\"",
  "1396": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入，以按照 compilerOptions 中指定的方式导入 \"importHelpers\"",
  "1397": "通过 {0} 从文件 \"{1}\" 导入，以导入 \"jsx\" 和 \"jsxs\" 工厂函数",
  "1398": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入，以导入 \"jsx\" 和 \"jsxs\" 工厂函数",
  "1400": "通过 \"{0}\" 从文件 \"{1}\" 引用",
  "1402": "通过 \"{0}\" 从文件 \"{1}\" 引用了库类型",
  "1403": "通过 \"{0}\" 从具有 packageId \"{2}\" 的文件 \"{1}\" 引用了库类型",
  "1405": "通过 \"{0}\" 从文件 \"{1}\" 引用了库",
  "1407": "通过在 \"{1}\" 中的包含模式 \"{0}\" 匹配",
  "1411": "由于指定了 \"{1}\"，因此包含了引用的项目 \"{0}\" 的输出",
  "1412": "由于已将 \"--module\" 指定为 \"none\"，因此包含了引用的项目 \"{0}\" 的输出",
  "1414": "由于指定了 \"{1}\"，因此包含了引用的项目 \"{0}\" 的源",
  "1415": "由于已将 \"--module\" 指定为 \"none\"，因此包含了引用的项目 \"{0}\" 的源",
  "1417": "在 compilerOptions 中指定的类型库 \"{0}\" 的入口点",
  "1418": "在 compilerOptions 中指定的类型库 \"{0}\" 的入口点，具有 packageId \"{1}\"",
  "1420": "隐式类型库 \"{0}\" 的入口点",
  "1421": "隐式类型库 \"{0}\" 的入口点，具有 packageId \"{1}\"",
  "1422": "CompilerOptions 中指定了库 \"{0}\"",
  "1425": "目标 \"{0}\" 的默认库",
  "1428": "文件是项目引用源 \"{0}\" 的输出",
  "1429": "文件重定向到文件 \"{0}\"",
  "1435": "未知的关键字或标识符。你是不是指“{0}”?",
  "1448": "“{0}”解析为仅类型声明，并且在启用“{1}”时必须使用仅类型重新导出进行重新导出。",
  "1458": "文件是 ECMAScript 模块，因为“{0}”具有值为 “module” 的字段 “type”",
  "1459": "文件是 CommonJS 模块，因为“{0}”具有值不是 “module” 的字段 “type”",
  "1460": "文件是 CommonJS 模块，因为“{0}”没有字段 “type”",
  "1471": "无法使用此构造导入模块“{0}”。说明符仅解析为 ES 模块，后者不能使用“require”进行导入。请改用 ECMAScript 导入。",
  "1479": "当前文件是 CommonJS 模块，其导入将生成“require”调用；但是，引用的文件是 ECMAScript 模块，它不能使用“require”进行导入。请考虑改为编写动态“import(\"{0}\")”调用。",
  "1480": "若要将此文件转换为 ECMAScript 模块，请将其文件扩展名更改为“{0}”，或者使用“{ \"type\": \"module\" }”创建本地 package.json 文件。",
  "1481": "若要将此文件转换为 ECMAScript 模块，请将其文件扩展名更改为“{0}”，或将字段“\"type\": \"module\"”添加到“{1}”。",
  "1482": "若要将此文件转换为 ECMAScript 模块，请将字段“\"type\": \"module\"”添加到“{0}”。",
  "1484": "“{0}”是一种类型，必须在启用 \"verbatimModuleSyntax\" 时使用仅类型导入进行导入。",
  "1485": "“{0}”解析为仅类型声明，并且必须在启用 \"verbatimModuleSyntax\" 时使用仅类型导入进行导入。",
  "1487": "不允许使用八进制转义序列。请使用语法“{0}”。",
  "1488": "不允许转义序列“{0}”。",
  "1491": "“{0}”修饰符不能出现在 \"using\" 声明中。",
  "1492": "“{0}”声明可能没有绑定模式。",
  "1495": "“{0}”修饰符不能出现在 \"await using\" 声明中。",
  "1501": "此正则表达式标志仅在面向“{0}”或更高版本时可用。",
  "1508": "意外的“{0}”。你是否想要使用反斜杠对其进行转义?",
  "1531": "“\\{0}”后面必须是括在大括号中的 Unicode 属性值表达式。",
  "1532": "此正则表达式中没有名为“{0}”的捕获组。",
  "1533": "此向后引用指的是一个不存在的组。此正则表达式中只有 {0} 个捕获组。",
  "1536": "字符类中不允许使用八进制转义序列和反向引用。如果这是转义序列，请改用语法“{0}”。",
  "1543": "当 ‘module’ 设置为 ‘{0}’ 时，将 JSON 文件导入 ECMAScript 模块需要 ‘type: “json”’ 导入属性。",
  "1544": "当 ‘module’ 设置为 ‘{0}’ 时，不允许从 JSON 文件到 ECMAScript 模块中的命名导入。",
  "2200": "在这些类型中，\"{0}\" 的类型不兼容。",
  "2201": "在这些类型中，\"{0}\" 返回的类型不兼容。",
  "2202": "调用签名返回类型 \"{0}\" 和 \"{1}\" 不兼容。",
  "2203": "构造签名返回类型 \"{0}\" 和 \"{1}\" 不兼容。",
  "2204": "没有参数的调用签名具有不兼容的返回类型 \"{0}\" 和 \"{1}\"。",
  "2205": "不带参数的构造签名具有不兼容的返回类型 \"{0}\" 和 \"{1}\"。",
  "2208": "此类型参数可能需要 `extends {0}` 约束。",
  "2209": "项目根不明确，但需要解析文件“{1}”中的导出映射项“{0}”。提供 `rootDir` 编译器选项以消除歧义。",
  "2210": "项目根不明确，但仍需要解析文件“{1}”中的导入映射项“{0}”。提供 `rootDir` 编译器选项以消除歧义。",
  "2300": "标识符“{0}”重复。",
  "2301": "实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。",
  "2303": "导入别名“{0}”的循环定义。",
  "2304": "找不到名称“{0}”。",
  "2305": "模块“{0}”没有导出的成员“{1}”。",
  "2306": "文件“{0}”不是模块。",
  "2307": "找不到模块“{0}”或其相应的类型声明。",
  "2308": "模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。",
  "2310": "类型“{0}”以递归方式将自身引用为基类。",
  "2311": "找不到名称“{0}”。你是否要在异步函数中写入此内容?",
  "2313": "类型参数“{0}”具有循环约束。",
  "2314": "泛型类型“{0}”需要 {1} 个类型参数。",
  "2315": "类型“{0}”不是泛型类型。",
  "2316": "全局类型“{0}”必须为类或接口类型。",
  "2317": "全局类型“{0}”必须具有 {1} 个类型参数。",
  "2318": "找不到全局类型“{0}”。",
  "2319": "“{1}”和“{2}”类型的命名属性“{0}”不完全相同。",
  "2320": "接口“{0}”不能同时扩展类型“{1}”和“{2}”。",
  "2321": "与类型“{0}”和“{1}”相比，堆栈深度过高。",
  "2322": "不能将类型“{0}”分配给类型“{1}”。",
  "2323": "无法重新声明导出的变量“{0}”。",
  "2324": "类型“{1}”中缺少属性“{0}”。",
  "2325": "属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。",
  "2326": "属性“{0}”的类型不兼容。",
  "2327": "属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。",
  "2328": "参数“{0}”和“{1}” 的类型不兼容。",
  "2329": "类型“{1}”中缺少类型“{0}”的索引签名。",
  "2330": "“{0}”和“{1}”索引签名不兼容。",
  "2339": "类型“{1}”上不存在属性“{0}”。",
  "2341": "属性“{0}”为私有属性，只能在类“{1}”中访问。",
  "2343": "此语法需要名为 \"{1}\" 的导入帮助器，\"{0}\" 中不存在该帮助器。请考虑升级 \"{0}\" 的版本。",
  "2344": "类型“{0}”不满足约束“{1}”。",
  "2345": "类型“{0}”的参数不能赋给类型“{1}”的参数。",
  "2348": "类型“{0}”的值不可调用。是否希望包括 \"new\"?",
  "2352": "类型 \"{0}\" 到类型 \"{1}\" 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 \"unknown\"。",
  "2353": "对象字面量只能指定已知属性，并且“{0}”不在类型“{1}”中。",
  "2354": "此语法需要一个导入的帮助程序，但找不到模块“{0}”。",
  "2365": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
  "2367": "此比较似乎是无意的，因为类型“{0}”和“{1}”没有重叠。",
  "2368": "类型参数名称不能为“{0}”。",
  "2372": "参数“{0}”不能引用它自身。",
  "2373": "参数“{0}”不能引用在它之后声明的标识符“{1}”。",
  "2374": "类型“{0}”的索引签名重复。",
  "2375": "类型 “{0}” 不能分配给“exactOptionalPropertyTypes: true”的类型 “{1}”。请考虑将 “undefined” 添加到目标属性的类型。",
  "2379": "类型为“{0}”的参数不能分配给类型为“{1}”且 “exactOptionalPropertyTypes: true” 的参数。请考虑将 “undefined” 添加到目标属性的类型。",
  "2389": "函数实现名称必须为“{0}”。",
  "2395": "合并声明“{0}”中的单独声明必须全为导出或全为局部声明。",
  "2397": "声明名称与内置全局标识符“{0}”冲突。",
  "2403": "后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
  "2407": "\"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数，但此处的类型为“{0}”。",
  "2411": "类型“{1}”的属性“{0}”不能赋给“{2}”索引类型“{3}”。",
  "2412": "类型 “{0}” 不能分配给“exactOptionalPropertyTypes: true”的类型 “{1}”。请考虑将 “undefined” 添加到目标类型。。",
  "2413": "“{0}”索引类型“{1}”不能分配给“{2}”索引类型“{3}”。",
  "2414": "类名不能为“{0}”。",
  "2415": "类“{0}”错误扩展基类“{1}”。",
  "2416": "类型“{1}”中的属性“{0}”不可分配给基类型“{2}”中的同一属性。",
  "2417": "类静态侧“{0}”错误扩展基类静态侧“{1}”。",
  "2418": "计算属性类型的值为 \"{0}\"，该值不能赋给 \"{1}\" 类型。",
  "2420": "类“{0}”错误实现接口“{1}”。",
  "2423": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
  "2425": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
  "2426": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
  "2427": "接口名称不能为“{0}”。",
  "2428": "“{0}”的所有声明都必须具有相同的类型参数。",
  "2430": "接口“{0}”错误扩展接口“{1}”。",
  "2431": "枚举名不能为“{0}”。",
  "2437": "模块“{0}”被具有相同名称的局部声明隐藏。",
  "2438": "导入名称不能为“{0}”。",
  "2440": "导入声明与“{0}”的局部声明冲突。",
  "2441": "标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。",
  "2442": "类型具有私有属性“{0}”的单独声明。",
  "2443": "属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。",
  "2444": "属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。",
  "2445": "属性“{0}”受保护，只能在类“{1}”及其子类中访问。",
  "2446": "属性“{0}”受保护，只能通过类“{1}”的实例进行访问。这是类“{2}”的实例。",
  "2447": "“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。",
  "2448": "声明之前已使用的块范围变量“{0}”。",
  "2449": "类“{0}”用于其声明前。",
  "2450": "枚举“{0}”用于其声明前。",
  "2451": "无法重新声明块范围变量“{0}”。",
  "2454": "在赋值前使用了变量“{0}”。",
  "2456": "类型别名“{0}”循环引用自身。",
  "2457": "类型别名不能为“{0}”。",
  "2459": "模块 \"{0}\" 在本地声明 \"{1}\"，但未导出它。",
  "2460": "模块 \"{0}\" 在本地声明 \"{1}\"，但它被导出为 \"{2}\"。",
  "2461": "类型“{0}”不是数组类型。",
  "2468": "找不到全局值“{0}”。",
  "2469": "“{0}”运算符不能应用于类型 \"symbol\"。",
  "2481": "无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。",
  "2484": "导出声明与“{0}”的导出声明冲突。",
  "2488": "类型“{0}”必须具有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2490": "迭代器的 \"{0}()\" 方法返回的类型必须具有 \"value\" 属性。",
  "2492": "无法在 catch 子句中重新声明标识符“{0}”。",
  "2493": "长度为 \"{1}\" 的元组类型 \"{0}\" 在索引 \"{2}\" 处没有元素。",
  "2495": "类型“{0}”不是数组类型或字符串类型。",
  "2497": "只能通过启用 \"{0}\" 标志并引用其默认导出，使用 ECMAScript 导入/导出来引用此模块。",
  "2498": "模块“{0}”使用 \"export =\" 且无法与 \"export *\" 一起使用。",
  "2502": "“{0}”在其自身的类型批注中得到直接或间接引用。",
  "2503": "找不到命名空间“{0}”。",
  "2504": "类型“{0}”必须具有返回异步迭代器的 \"[Symbol.asyncIterator]()\" 方法。",
  "2506": "“{0}”在其自身的基表达式中得到直接或间接引用。",
  "2507": "类型“{0}”不是构造函数类型。",
  "2509": "基构造函数返回类型 \"{0}\" 不是具有静态已知成员的对象类型或对象类型的交集。",
  "2513": "无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。",
  "2515": "非抽象类“{0}”不会实现继承自“{2}”类的抽象成员 {1}。",
  "2520": "标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。",
  "2527": "“{0}”的推断类型引用不可访问的“{1}”类型。需要类型批注。",
  "2529": "标识符“{0}”重复。编译器在包含异步函数的模块的顶层范围中保留名称“{1}”。",
  "2530": "属性“{0}”与索引签名不兼容。",
  "2536": "类型“{0}”无法用于索引类型“{1}”。",
  "2537": "类型“{0}”没有匹配的类型“{1}”的索引签名。",
  "2538": "类型“{0}”不能作为索引类型使用。",
  "2539": "无法为“{0}”赋值，因为它不是变量。",
  "2540": "无法为“{0}”赋值，因为它是只读属性。",
  "2542": "类型“{0}”中的索引签名仅允许读取。",
  "2547": "异步迭代器的 \"{0}()\" 方法返回的类型必须是具有 \"value\" 属性的类型的承诺。",
  "2548": "类型“{0}”不是数组类型，或者没有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2549": "类型“{0}”不是数组类型或字符串类型，或者没有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2550": "属性“{0}”在类型“{1}”上不存在。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为“{2}”或更高版本。",
  "2551": "属性“{0}”在类型“{1}”上不存在。你是否指的是“{2}”?",
  "2552": "找不到名称“{0}”。你是否指的是“{1}”?",
  "2554": "应有 {0} 个参数，但获得 {1} 个。",
  "2555": "应有至少 {0} 个参数，但获得 {1} 个。",
  "2558": "应有 {0} 个类型参数，但获得 {1} 个。",
  "2559": "类型“{0}”与类型“{1}”不具有相同的属性。",
  "2560": "类型“{0}”的值没有与类型“{1}”相同的属性。你是想调用它吗?",
  "2561": "对象字面量只能指定已知的属性，但“{0}”中不存在类型“{1}”。是否要写入 {2}?",
  "2564": "属性“{0}”没有初始化表达式，且未在构造函数中明确赋值。",
  "2565": "在赋值前使用了属性“{0}”。",
  "2568": "类型“{1}”上不存在属性“{0}”。你是否是指“{2}”?",
  "2570": "找不到名称“{0}”。你是否是指“{1}”?",
  "2575": "没有需要 {0} 参数的重载，但存在需要 {1} 或 {2} 参数的重载。",
  "2576": "属性“{0}”在类型“{1}”上不存在。你的意思是改为访问静态成员“{2}”吗?",
  "2580": "找不到名称“{0}”。是否需要安装 Node.js 的类型定义? 请尝试运行 `npm i --save-dev @types/node`。",
  "2581": "找不到名称 \"{0}\"。是否需要安装 jQuery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`。",
  "2582": "找不到名称 \"{0}\"。是否需要安装测试运行器的类型定义? 请尝试使用 `npm i --save-dev @types/jest` 或 `npm i --save-dev @types/mocha`。",
  "2583": "找不到名称“{0}”。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为“{1}”或更高版本。",
  "2584": "找不到名称“{0}”。是否需要更改目标库? 请尝试更改 “lib” 编译器选项以包括 “dom”。",
  "2585": "“{0}” 仅指类型，但在此处用作值。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为 es2015 或更高版本。",
  "2588": "无法分配到 \"{0}\" ，因为它是常数。",
  "2591": "找不到名称“{0}”。是否需要安装 Node.js 的类型定义? 请尝试运行 `npm i --save-dev @types/node`，然后将 \"node\" 添加到 tsconfig 的 types 字段。",
  "2592": "找不到名称“{0}”。是否需要安装 jQuery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`，然后将 “jquery” 添加到 teconfig 中的类型字段。",
  "2593": "找不到名称“{0}”。是否需要安装测试运行器的类型定义? 请尝试使用 `npm i --save-dev @types/jest` 或 `npm i --save-dev @types/mocha`，然后将 “jest” 或 “mocha” 添加到 tsconfig 中的类型字段。。",
  "2594": "此模块是使用 “export =” 声明的，只能在使用“{0}”标志时用于默认导入。",
  "2595": "仅可使用默认导入来导入“{0}”。",
  "2596": "只能通过启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2597": "只能使用 \"require\" 调用或使用默认导入来导入“{0}”。",
  "2598": "只能通过使用 \"require\" 调用或启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2603": "类型“{1}”中的属性“{0}”不可分配给类型“{2}”。",
  "2604": "JSX 元素类型“{0}”不具有任何构造签名或调用签名。",
  "2606": "JSX 展开特性的“{0}”属性不能分配给目标属性。",
  "2607": "JSX 元素类不支持特性，因为它不具有“{0}”属性。",
  "2608": "全局类型 \"JSX.{0}\" 不可具有多个属性。",
  "2610": "\"{0}\" 在类 \"{1}\" 中定义为访问器，但这里在 \"{2}\" 中重写为实例属性。",
  "2611": "\"{0}\" 在类 \"{1}\" 中定义为属性，但这里在 \"{2}\" 中重写为访问器。",
  "2612": "属性 \"{0}\" 将覆盖 \"{1}\" 中的基属性。如果是有意的，请添加初始值设定项。否则，请添加 \"declare\" 修饰符或删除多余的声明。",
  "2613": "模块 \"{0}\" 没有默认导出。你是想改为使用 \"import { {1} } from {0}\" 吗?",
  "2614": "模块 \"{0}\" 没有导出的成员 \"{1}\"。你是想改用 \"import {1} from {0}\" 吗?",
  "2615": "属性“{0}”的类型在已映射的类型“{1}”中循环引用其自身。",
  "2616": "仅可使用 \"import {1} = require({2})\" 或默认导入来导入“{0}”。",
  "2617": "仅可使用 \"import {1} = require({2})\" 或通过启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2618": "源具有 {0} 个元素，但目标需要 {1} 个。",
  "2619": "源具有 {0} 个元素，但目标仅允许 {1} 个。",
  "2620": "目标仅允许 {0} 个元素，但源中的元素可能不够。",
  "2621": "目标仅允许 {0} 个元素，但源中的元素可能更多。",
  "2623": "源不提供目标中位置 {0} 处所需元素的匹配项。",
  "2624": "源不提供目标中位置 {0} 处可变元素的匹配项。",
  "2625": "源中位置 {0} 的可变元素与目标中位置 {1} 的元素不匹配。",
  "2626": "源中位置 {0} 的类型与目标中位置 {1} 的类型不兼容。",
  "2627": "源中位置 {0} 到 {1} 的类型与目标中位置 {2} 的类型不兼容。",
  "2628": "无法为“{0}”赋值，因为它是枚举。",
  "2629": "无法为“{0}”赋值，因为它是类。",
  "2630": "无法为“{0}”赋值，因为它是函数。",
  "2631": "无法为“{0}”赋值，因为它是命名空间。",
  "2632": "无法为“{0}”赋值，因为它是导入。",
  "2634": "“{0}”索引签名不兼容。",
  "2635": "类型“{0}”没有类型参数列表适用的签名。",
  "2636": "类型“{0}”不能分配给类型“{1}”，如方差批注所示。",
  "2638": "类型 \"{0}\" 可以表示基元值，该值不允许作为“in”运算符的右操作数。",
  "2649": "无法扩充具有值导出的模块“{0}”，因为它解析为一个非模块的实体。",
  "2650": "非抽象类表达式缺少“{0}”的以下成员的实现: {1} 和 {2} 等。",
  "2652": "合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。",
  "2653": "非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。",
  "2654": "非抽象类“{0}”缺少“{1}”的以下成员的实现: {2}。",
  "2655": "非抽象类“{0}”缺少“{1}”的以下成员的实现: {2} 和 {3} 等。",
  "2656": "非抽象类表达式缺少“{0}”的以下成员的实现: {1}。",
  "2658": "类型“{0}”提供的内容与签名“{1}”不匹配。",
  "2661": "无法导出“{0}”。仅可从模块中导出本地声明。",
  "2662": "找不到名称“{0}”。你的意思是静态成员“{1}.{0}”?",
  "2663": "找不到名称“{0}”。你的意思是实例成员“this.{0}”?",
  "2664": "扩大中的模块名无效，找不到模块“{0}”。",
  "2665": "扩大中的模块名称无效。模块“{0}”解析到位于“{1}”处的非类型化模块，其无法扩大。",
  "2671": "无法扩大模块“{0}”，因为它解析为非模块实体。",
  "2672": "不可将“{0}”构造函数类型分配给“{1}”构造函数类型。",
  "2673": "类“{0}”的构造函数是私有的，仅可在类声明中访问。",
  "2674": "类“{0}”的构造函数是受保护的，仅可在类声明中访问。",
  "2675": "无法扩展类“{0}”。类构造函数标记为私有。",
  "2678": "类型“{0}”不可与类型“{1}”进行比较。",
  "2680": "“{0}”参数必须是第一个参数。",
  "2684": "类型为“{0}”的 \"this\" 上下文不能分配给类型为“{1}”的方法的 \"this\"。",
  "2686": "“{0}”指 UMD 全局，但当前文件是模块。请考虑改为添加导入。",
  "2687": "“{0}”的所有声明必须具有相同的修饰符。",
  "2688": "找不到“{0}”的类型定义文件。",
  "2689": "无法扩展接口“{0}”。您是否想使用 \"implements\"?",
  "2690": "“{0}”仅引用一个类型，但在此处用作一个值。你是否想要使用“{0} 中的 {1}”?",
  "2692": "“{0}”是基元，但“{1}”是包装器对象。如可能首选使用“{0}”。",
  "2693": "“{0}”仅表示类型，但在此处却作为值使用。",
  "2694": "命名空间“{0}”没有已导出的成员“{1}”。",
  "2699": "静态属性“{0}”与构造函数“{1}”的内置属性函数“{0}”冲突。",
  "2702": "“{0}”仅指类型，但在此用作命名空间。",
  "2707": "泛型类型“{0}”需要介于 {1} 和 {2} 类型参数之间。",
  "2708": "不能将命名空间“{0}”用作值。",
  "2709": "不能将命名空间“{0}”用作类型。",
  "2710": "“{0}”被指定了两次。将覆盖名为“{0}”的特性。",
  "2713": "无法访问“{0}.{1}”，因为“{0}”是类型，不是命名空间。是否要使用“{0}[\"{1}\"]”检索“{0}”中“{1}”属性的类型?",
  "2715": "不能在构造函数中访问类“{1}”中的抽象属性“{0}”。",
  "2716": "类型参数“{0}”具有循环默认值。",
  "2717": "后续属性声明必须属于同一类型。属性“{0}”的类型必须为“{1}”，但此处却为类型“{2}”。",
  "2718": "重复的属性 \"{0}\"。",
  "2719": "类型“{0}”无法分配给类型“{1}”。存在具有此名称的两种不同类型，但它们是不相关的。",
  "2720": "类“{0}”错误实现类“{1}”。你是想扩展“{1}”并将其成员作为子类继承吗?",
  "2724": "“{0}”没有导出的成员“{1}”。你是否指的是“{2}”?",
  "2725": "使用模块 {0} 将目标设置为 ES5 及更高版本时，类名不能为 \"Object\"。",
  "2726": "找不到“{0}”的库定义。",
  "2727": "找不到“{0}”的库定义。你是指“{1}”?",
  "2728": "在此处声明了 \"{0}\"。",
  "2729": "属性 \"{0}\" 在其初始化前已被使用。",
  "2732": "找不到模块“{0}”。请考虑使用 \"--resolveJsonModule\" 导入带 \".json\" 扩展的模块。",
  "2733": "属性 \"{0}\" 也在此处声明。",
  "2735": "你是想将 \"{0}\" 限制为类型 \"new (...args: any[]) => {1}\" 吗?",
  "2736": "运算符 \"{0}\" 不能应用于类型 \"{1}\"。",
  "2739": "类型“{0}”缺少类型“{1}”中的以下属性: {2}",
  "2740": "类型“{0}”缺少类型“{1}”的以下属性: {2} 及其他 {3} 项。",
  "2741": "类型 \"{1}\" 中缺少属性 \"{0}\"，但类型 \"{2}\" 中需要该属性。",
  "2742": "如果没有引用 \"{1}\"，则无法命名 \"{0}\" 的推断类型。这很可能不可移植。需要类型注释。",
  "2743": "没有需要 {0} 类型参数的重载，但存在需要 {1} 或 {2} 类型参数的重载。",
  "2745": "此 JSX 标记的 \"{0}\" 属性需要类型 \"{1}\"，该类型需要多个子级，但仅提供了一个子级。",
  "2746": "此 JSX 标记的 \"{0}\" 属性需要 \"{1}\" 类型的子级，但提供了多个子级。",
  "2747": "\"{0}\" 组件不接受文本作为子元素。JSX 中的文本类型为 \"string\"，但 \"{1}\" 的预期类型为 \"{2}\"。",
  "2748": "启用“{0}”时，无法访问环境常量枚举。",
  "2749": "“{0}”表示值，但在此处用作类型。是否指“类型 {0}”?",
  "2755": "不可调用 \"{0}\" 类型的任何组成部分。",
  "2756": "\"{0}\" 类型的部分要素不可调用。",
  "2757": "类型 \"{0}\" 没有调用签名。",
  "2758": "联合类型 \"{0}\" 的每个成员都有签名，但这些签名都不能互相兼容。",
  "2759": "不可构造 \"{0}\" 类型的任何组成部分。",
  "2760": "\"{0}\" 类型的部分要素不可构造。",
  "2761": "类型 \"{0}\" 没有构造签名。",
  "2762": "联合类型 \"{0}\" 的每个成员都有构造签名，但这些签名都不能互相兼容。",
  "2763": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但 for-of 将始终发送 \"{0}\"。",
  "2764": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但数组扩张将始终发送 \"{0}\"。",
  "2765": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但数组析构将始终发送 \"{0}\"。",
  "2766": "无法将迭代委托到值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但包含它的生成器将始终发送 \"{0}\"。",
  "2767": "迭代器的 \"{0}\" 属性必须是方法。",
  "2768": "异步迭代器的 \"{0}\" 属性必须是方法。",
  "2772": "第 {0} 个重载(共 {1} 个)，“{2}”，出现以下错误。",
  "2782": "\"{0}\" 需要显式类型注释。",
  "2783": "多次指定了 \"{0}\"，因此将重写此用法。",
  "2786": "“{0}”不能用作 JSX 组件。",
  "2787": "其返回类型 \"{0}\" 不是有效的 JSX 元素。",
  "2788": "其实例类型 \"{0}\" 不是有效的 JSX 元素。",
  "2789": "其元素类型 \"{0}\" 不是有效的 JSX 元素。",
  "2792": "找不到模块“{0}”。你的意思是要将 \"moduleResolution\" 选项设置为 \"nodenext\"，还是要将别名添加到 \"paths\" 选项中?",
  "2794": "应为 {0} 个参数，但得到的却是 {1} 个。你是否忘了将类型参数中的 \"void\" 包含到 \"Promise\"?",
  "2801": "此条件将始终返回 true，因为此“{0}”已始终定义。",
  "2802": "只有在使用 \"--downlevelIteration\" 标志或 \"--target\" 为 \"es2015\" 或更高版本时，才能循环访问类型“{0}”。",
  "2803": "无法赋值给私有方法“{0}”。私有方法不可写。",
  "2804": "标识符 \"{0}\" 重复。静态元素和实例元素不能共享相同的专用名称。",
  "2807": "此语法需要一个名为 \"{1}\" 且包含 {2} 参数的导入帮助程序，该帮助程序与 \"{0}\" 中的相应帮助程序不兼容。请考虑升级 \"{0}\" 的版本。",
  "2811": "属性“{0}”的初始化表达式",
  "2812": "属性“{0}”在类型 “{1}” 上不存在。请尝试将 “lib” 编译器选项更改为包含 “dom”。",
  "2813": "类声明无法实现“{0}”的重载列表。",
  "2817": "属性“{0}”没有初始化表达式，并且未在类静态块中明确分配。",
  "2818": "标识符“{0}”重复。在静态初始化表达式中中发出 “super” 引用时，编译器保留名称“{1}”。",
  "2819": "命名空间名称不能为“{0}”。",
  "2820": "类型“{0}”不可分配给类型“{1}”。你的意思是“{2}”?",
  "2833": "找不到命名空间“{0}”。你是否指的是“{1}”?",
  "2835": "当“--moduleResolution”为“node16” 或“nodenext”时，相对导入路径需要 ECMAScript 导入中的显式文件扩展名。你是想使用 \"{0}\" 吗?",
  "2838": "\"{0}\" 的所有声明必须具有相同的限制。",
  "2839": "此条件将始终返回“{0}”，因为 JavaScript 按引用而不是值比较对象。",
  "2840": "接口无法扩展“{0}”这样的基元类型。它只能扩展其他命名对象类型。",
  "2842": "“{0}”是“{1}”的未使用重命名。是否打算将其用作类型批注?",
  "2843": "我们只能通过在此处为整个参数添加类型来写入“{0}”的类型。",
  "2844": "实例成员变量“{0}”的类型不能引用构造函数中声明的标识符“{1}”。",
  "2845": "此条件将始终返回“{0}”。",
  "2846": "如果没有“导入类型”，则无法导入声明文件。是否要改为导入实现文件“{0}”?",
  "2849": "目标签名提供的自变量太少。预期为 {0} 个或更多，但实际为 {1} 个。",
  "2855": "父类定义的类字段“{0}”无法通过 super 在子类中访问。",
  "2859": "比较类型“{0}”和“{1}”的复杂性过高。",
  "2862": "类型“{0}”是泛型的，只能编制索引以供读取。",
  "2863": "类无法扩展“{0}”这样的基元类型。类只能扩展可构造值。",
  "2864": "类无法实现类似于“{0}”的基元类型。它只能实现其他命名对象类型。",
  "2865": "导入“{0}”与本地值冲突，因此在启用“isolatedModules”时必须使用仅类型导入进行声明。",
  "2866": "导入“{0}”与此文件中使用的全局值冲突，因此在启用“isolatedModules”时必须使用仅类型导入进行声明。",
  "2867": "找不到名称“{0}”。你是否需要安装 Bun 的类型定义?请尝试运行 `npm i --save-dev @types/bun`。",
  "2868": "找不到名称“{0}”。你是否需要安装 Bun 的类型定义?请尝试运行 `npm i --save-dev @types/bun`，然后将 \"bun\" 添加到 tsconfig 的 types 字段。",
  "2874": "此 JSX 标记要求 ‘{0}’ 在范围内，但找不到它。",
  "2875": "此 JSX 标记要求模块路径 ‘{0}’ 存在，但找不到任何路径。请确保已安装相应包的类型。",
  "2876": "重写此相对导入路径并不安全，因为它看起来像文件名，但实际上解析为 ‘{0}’。",
  "2877": "此导入使用 ‘{0}’ 扩展解析为输入 TypeScript 文件，但不会在发出期间重写，因为它不是相对路径。",
  "2879": "使用 JSX 片段需要片段工厂 ‘{0}’ 在范围内，但找不到它。",
  "4000": "导入声明“{0}”使用的是专用名称“{1}”。",
  "4002": "导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4004": "导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4006": "导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4008": "导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4010": "导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4012": "导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4014": "导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4016": "导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4019": "导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。",
  "4020": "导出的类“{0}”的 \"extends\" 子句具有或正在使用专用名称“{1}”。",
  "4021": "导出的类的 \"extends\" 子句具有或正在使用专用名称“{0}”。",
  "4022": "导出接口“{0}”的 \"extends\" 子句具有或正在使用专用名称“{1}”。",
  "4023": "导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4024": "导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4025": "导出的变量“{0}”具有或正在使用专用名称“{1}”。",
  "4026": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4027": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。",
  "4028": "导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。",
  "4029": "导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4030": "导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4031": "导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。",
  "4032": "导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4033": "导出接口的属性“{0}”具有或正在使用专用名称“{1}”。",
  "4034": "导出类中的公共静态 setter“{0}”的参数类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4035": "导出类中的公共静态 setter“{0}”的参数类型具有或正在使用专用名称“{1}”。",
  "4036": "导出类中的公共 setter“{0}”的参数类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4037": "导出类中的公共 setter“{0}”的参数类型具有或正在使用专用名称“{1}”。",
  "4038": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4039": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4040": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用专用名称“{1}”。",
  "4041": "导出类中的公共 getter“{0}”的返回类型具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4042": "导出类中的公共 getter“{0}”的返回类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4043": "导出类中的公共 getter“{0}”的返回类型具有或正在使用专用名称“{1}”。",
  "4044": "导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4045": "导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。",
  "4046": "导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4047": "导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。",
  "4048": "导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4049": "导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。",
  "4050": "导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4051": "导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4052": "导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。",
  "4053": "导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4054": "导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4055": "导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。",
  "4056": "导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4057": "导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。",
  "4058": "导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4059": "导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4060": "导出函数的返回类型具有或正在使用专用名称“{0}”。",
  "4061": "导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4062": "导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4063": "导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4064": "导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4065": "导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4066": "导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4067": "导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4068": "导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4069": "导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4070": "导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4071": "导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4072": "导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4073": "导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4074": "导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4075": "导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4076": "导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。",
  "4077": "导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4078": "导出函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4081": "导出的类型别名“{0}”已经或正在使用专用名称“{1}”。",
  "4082": "模块的默认导出具有或正在使用专用名称“{0}”。",
  "4083": "已导出类型别名的类型参数“{0}”具有或正使用专用名称“{1}”。",
  "4084": "导出的类型别名“{0}”具有或正在使用模块“{2}”中的专用名称“{1}”。",
  "4085": "推断类型“{0}”的 Extends 子句具有或正在使用专用名称“{1}”。",
  "4091": "来自导出接口的索引签名的参数“{0}”具有或正在使用来自私有模块“{2}”的名称“{1}”。",
  "4092": "来自导出接口的索引签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4094": "导出匿名类类型的属性“{0}”可能不是私有或受保护的属性。",
  "4095": "导出类的公共静态方法“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4096": "导出类的公共静态方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4097": "导出类的公共静态方法“{0}”具有或正在使用专用名称“{1}”。",
  "4098": "导出类的公共方法“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4099": "导出类的公共方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4100": "导出类的公共方法“{0}”具有或正在使用专用名称“{1}”。",
  "4101": "导出接口的方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4102": "导出接口的方法“{0}”具有或正在使用专用名称“{1}”。",
  "4103": "已导出映射对象类型的类型参数 \"{0}\" 使用专用名称 \"{1}\" 。",
  "4104": "类型 \"{0}\" 为 \"readonly\"，不能分配给可变类型 \"{1}\"。",
  "4105": "不能在类型参数上访问专用或受保护的成员 \"{0}\"。",
  "4106": "访问器的参数 \"{0}\" 具有或正在使用专用名称 \"{1}\"。",
  "4107": "访问器的参数 \"{0}\" 具有或正在使用专用模块 \"{2}\" 中的名称 \"{1}\" 。",
  "4108": "访问器的参数 \"{0}\" 具有或正在使用外部模块 \"{2}\" 中的名称 \"{1}\" ，但不能为其命名。",
  "4109": "\"{0}\" 的类型参数循环引用自身。",
  "4111": "属性“{0}”来自索引签名，因此必须使用[“{0}”]访问它。",
  "4112": "此成员不能有 \"override\" 修饰符，因为它的包含类 \"{0}\" 不扩展其他类。",
  "4113": "此成员不能有 \"override\" 修饰符，因为它未在基类 \"{0}\" 中声明。",
  "4114": "此成员必须有 \"override\" 修饰符，因为它替代基类 \"{0}\" 中的一个成员。",
  "4115": "此参数属性必须具有 “override” 修饰符，因为它会替代基类“{0}”中的成员。",
  "4116": "此成员必须有 \"override\" 修饰符，因为它替代基类 \"{0}\" 中声明的一个抽象方法。",
  "4117": "此成员不能有 “override” 修饰符，因为它未在基类“{0}”中声明。你是否指的是“{1}”?",
  "4118": "无法序列化此节点的类型，因为无法序列化其属性“{0}”。",
  "4119": "此成员必须具有带 “@override” 标记的 JSDoc 注释，因为它会替代基类“{0}”中的成员。",
  "4120": "此参数属性必须具有带 “@override” 标记的 JSDoc 注释，因为它将替代基类“{0}”中的成员。",
  "4121": "此成员不能具有带 “@override” 标记的 JSDoc 注释，因为所包含的类“{0}”不会扩展其他类。",
  "4122": "此成员不能具有带 “@override” 标记的 JSDoc 注释，因为未在基类“{0}”中对其进行声明。",
  "4123": "此成员不能具有带 “override” 标记的 JSDoc 注释，因为未在基类“{0}”中对其进行声明。你是否指的是“{1}”?",
  "4124": "值“{1}”的编译器选项“{0}”不稳定。使用夜间 TypeScript 消除此错误。请尝试使用 “npm install -D typescript@next” 进行更新。",
  "4125": "“{0}.{1}”的每个声明的值不同，其中应为“{2}”，但给出的是“{3}”。",
  "4126": "“{0}.{1}”的一个值是字符串“{2}”，另一个值被假定为未知数值。",
  "5001": "当前主机不支持“{0}”选项。",
  "5010": "文件规范不能以递归目录通配符结尾(\"**\"):“{0}”。",
  "5012": "无法读取文件“{0}”: {1}。",
  "5023": "未知的编译器选项“{0}”。",
  "5024": "编译器选项“{0}”需要类型 {1} 的值。",
  "5025": "未知的编译器选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5033": "无法写入文件“{0}”: {1}。",
  "5051": "仅当提供了选项 \"--inlineSourceMap\" 或选项 \"--sourceMap\" 时，才能使用选项“{0}”。",
  "5052": "无法在不指定选项“{1}”的情况下指定选项“{0}”。",
  "5053": "选项“{0}”不能与选项“{1}”同时指定。",
  "5054": "已在“{0}”中定义了 \"tsconfig.json\" 文件。",
  "5055": "无法写入文件“{0}”，因为它会覆盖输入文件。",
  "5056": "无法写入文件“{0}”，因为它会被多个输入文件覆盖。",
  "5057": "无法在指定目录找到 tsconfig.json 文件:“{0}”。",
  "5058": "指定的路径不存在:“{0}”。",
  "5059": "\"--reactNamespace\" 的值无效。“{0}”不是有效的标识符。",
  "5061": "模式“{0}”最多只可具有一个 \"*\" 字符。",
  "5062": "模式 \"{1}\" 中的替代项 \"{0}\" 最多只能有一个 \"*\" 字符",
  "5063": "模式“{0}”的替代应为数组。",
  "5064": "模式“{1}”的替换“{0}”类型不正确，应为 \"string\"，实际为“{2}”。",
  "5065": "文件规范不能包含出现在递归目录通配符(\"*\"): “{0}”后的父目录(\"..\")。",
  "5066": "模式“{0}”的替换模式不应为空数组。",
  "5067": "\"jsxFactory\" 的值无效。“{0}”不是有效的标识符或限定名称。",
  "5069": "无法在不指定选项 {1} 或选项 {2} 的情况下指定选项 {0}。",
  "5072": "未知的生成选项 \"{0}\"。",
  "5073": "生成选项 \"{0}\" 需要类型 {1} 的值。",
  "5075": "\"{0}\" 可赋给 \"{1}\" 类型的约束，但可以使用约束 \"{2}\" 的其他子类型实例化 \"{1}\"。",
  "5076": "不能在不使用括号的情况下混用 \"{0}\" 和 \"{1}\" 操作。",
  "5077": "未知的生成选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5078": "未知观察选项 \"{0}\"。",
  "5079": "未知的监视选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5080": "观察选项 \"{0}\" 需要 {1} 类型的值。",
  "5081": "无法在当前目录找到 tsconfig.json 文件: {0}。",
  "5082": "“{0}”可以使用与“{1}”无关的任意类型进行实例化。",
  "5083": "无法读取文件“{0}”。",
  "5088": "推断类型“{0}”引用的类型具有无法简单序列化的循环结构。必须具有类型注释。",
  "5089": "选项 \"jsx\" 为“{1}”时，不能指定选项“{0}”。",
  "5091": "启用“{0}”时，无法禁用选项“preserveConstEnums”。",
  "5092": "“{0}”文件的根值必须是一个对象。",
  "5093": "编译器选项“--{0}”只能与 “--build” 一起使用。",
  "5094": "编译器选项“--{0}”不能与 “--build” 一起使用。",
  "5095": "只有在“module”设置为“preserve”或“es2015”或更高版本时，才能使用选项“{0}”。",
  "5097": "启用“allowImportingTsExtensions”时，导入路径只能以“{0}”扩展名结尾。",
  "5098": "只有在“moduleResolution”设置为“node16”、“nodenext”或“bundler”时，才能使用选项“{0}”。",
  "5101": "选项“{0}”已弃用，并将停止在 TypeScript {1} 中运行。指定 compilerOption“ignoreDeprecations”:“{2}”以使此错误静音。",
  "5102": "选项“{0}”已删除。请从配置中删除它。",
  "5104": "选项“{0}”是冗余选项，不能与选项“{1}”同时指定。",
  "5106": "请改用“{0}”。",
  "5107": "选项“{0}={1}”已弃用，并将停止在 TypeScript {2} 中运行。指定 compilerOption“ignoreDeprecations”:“{3}”以使此错误静音。",
  "5108": "选项“{0}={1}”已删除。请从配置中删除它。",
  "5109": "当选项“module”设置为“{1}”时，选项“moduleResolution”必须设置为“{0}”(或保留为未指定)。",
  "5110": "当选项“moduleResolution”设置为“{1}”时，选项“module”必须设置为“{0}”。",
  "6023": "语法: {0}",
  "6026": "示例: {0}",
  "6029": "版本 {0}",
  "6044": "编译器选项“{0}”需要参数。",
  "6045": "响应文件“{0}”中引号不配对。",
  "6046": "“{0}”选项的参数必须为 {1}。",
  "6048": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
  "6050": "无法打开文件“{0}”。",
  "6051": "区域设置文件 {0} 已损坏。",
  "6053": "找不到文件“{0}”。",
  "6054": "文件“{0}”具有不受支持的扩展名。仅支持 {1} 扩展名。",
  "6059": "文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。",
  "6064": "选项“{0}”只能在 \"tsconfig.json\" 文件中指定或在命令行上设置为 \"null\"。",
  "6082": "--{0} 旁仅支持 \"amd\" 和 \"system\" 模块。",
  "6086": "======== 正在从“{1}”解析模块“{0}”。========",
  "6087": "显示指定了模块解析类型:“{0}”。",
  "6088": "未指定模块解析类型，正在使用“{0}”。",
  "6089": "======== 模块名“{0}”已成功解析为“{1}”。========",
  "6090": "======== 未解析模块名“{0}”。========",
  "6091": "指定了 \"paths“ 选项，正在查找模式以匹配模块名“{0}”。",
  "6092": "模块名“{0}”，匹配的模式“{1}”。",
  "6093": "正在尝试替换“{0}”，候选模块位置:“{1}”。",
  "6094": "正在相对于基 URL“{1}”-“{2}”解析模块名“{0}”。",
  "6095": "正在将模块作为文件/文件夹进行加载，候选模块位置“{0}”，目标文件类型: {1}。",
  "6096": "文件“{0}”不存在。",
  "6097": "文件“{0}”存在 - 将其用作名称解析结果。",
  "6098": "正在从 \"node_modules\" 文件夹加载模块“{0}”，目标文件类型: {1}。",
  "6099": "在“{0}”处找到了 \"package.json\"。",
  "6100": "\"package.json\" 没有“{0}”字段。",
  "6101": "\"package.json\" 具有引用“{2}”的“{0}”字段“{1}”。",
  "6104": "检查“{0}”是否是“{1}”-“{2}”的最长匹配前缀。",
  "6105": "\"package.json\" 中 \"{0}\" 字段的类型应为 \"{1}\"，但实际为 \"{2}\" 。",
  "6106": "\"baseUrl\" 选项设置为“{0}”，可使用此值解析非相关模块名称“{1}”。",
  "6107": "设置了 \"rootDirs\" 选项，可将其用于解析相对模块名称“{0}”。",
  "6108": "“{0}”的最长匹配前缀为“{1}”。",
  "6109": "正在从根目录“{1}”加载“{0}”，候选位置“{2}”。",
  "6116": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，根目录“{2}”。========",
  "6119": "======== 类型引用指令“{0}”已成功解析为“{1}”，主要: {2}。========",
  "6120": "======== 未解析类型引用指令“{0}”。========",
  "6121": "正在使用主搜索路径“{0}”解析。",
  "6123": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，未设置根目录。========",
  "6125": "正在 \"node_modules\" 文件夹中查找，初始位置为“{0}”。",
  "6127": "======== 正在解析类型引用指令“{0}”，未设置包含文件，根目录“{1}”。========",
  "6128": "======== 正在解析类型引用指令“{0}”，未设置包含文件，未设置根目录。========",
  "6130": "正在解析“{0}”的真实路径，结果为“{1}”。",
  "6131": "无法使用选项“{0}”来编译模块，除非 \"--module\" 标记为 \"amd\" 或 \"system\"。",
  "6132": "文件名“{0}”的扩展名为“{1}”，请去除它。",
  "6133": "已声明“{0}”，但从未读取其值。",
  "6137": "无法导入类型声明文件。请考虑导入“{0}”，而不是“{1}”。",
  "6138": "已声明属性“{0}”，但从未读取其值。",
  "6140": "项目“{0}”中启用了键入内容的自动发现。使用缓存位置“{2}”运行模块“{1}”的额外解决传递。",
  "6142": "模块“{0}”已解析为“{1}”，但尚未设置 \"--jsx\"。",
  "6144": "模块“{0}”解析为文件“{1}”中本地声明的环境模块。",
  "6147": "在位置“{1}”的缓存中找到模块“{0}”的解析。",
  "6148": "目录“{0}”不存在，正在跳过该目录中的所有查找。",
  "6164": "正在跳过看起来像绝对 URI、目标文件类型的模块“{0}”: {1}。",
  "6182": "检测到范围包，请在“{0}”中查看",
  "6183": "正在重用旧程序“{1}”中模块“{0}”的解析，已成功将其解析为“{2}”。",
  "6184": "正在重用旧程序“{1}”中模块“{0}”的解析，已成功将其解析为包 ID 为“{3}”的“{2}”。",
  "6194": "找到 {0} 个错误。注意文件更改。",
  "6196": "“{0}”已声明，但从未使用过。",
  "6200": "以下标识符的定义与另一个文件中的定义冲突: {0}",
  "6202": "项目引用不能形成环形图。检测到循环: {0}",
  "6203": "此处也声明了 \"{0}\"。",
  "6207": "\"package. json\" 没有与版本 \"{0}\" 匹配的 \"typesVersions\" 项。",
  "6208": "\"package. json\" 具有与编译器版本 \"{1}\" 匹配的 \"typesVersions\" 项 \"{0}\"，它需要与模块名称 \"{2}\" 匹配的模式。",
  "6209": "\"package. json\" 具有 \"typesVersions\" 项 \"{0}\"，它不是有效的 semver 范围。",
  "6210": "未提供 \"{0}\" 的自变量。",
  "6215": "使用项目引用重定向“{0}”的编译器选项。",
  "6217": "找到 {0} 个错误。",
  "6218": "======== 模块名 \"{0}\" 已成功解析为 \"{1}\"，包 ID 为 \"{2}\"。========",
  "6219": "======== 类型引用指令 \"{0}\" 已成功解析为 \"{1}\" ，包 ID 为 \"{2}\"，主要: {3}。========",
  "6220": "\"package. json\" 具有错误的 \"{0}\" 字段。",
  "6229": "标记“{0}”至少需要“{1}”个参数，但 JSX 工厂“{2}”最多可提供“{3}”个。",
  "6230": "选项“{0}”只能在 \"tsconfig.json\" 文件中指定，或者在命令行上设置为 \"false\" 或 \"null\"。",
  "6231": "无法解析具有表达式的路径“{0}”: {1}。",
  "6236": "未提供 rest 形参“{0}”的实参。",
  "6239": "根据前面缓存的查找，文件“{0}”存在。",
  "6240": "根据前面缓存的查找，文件“{0}”不存在。",
  "6241": "在位置“{1}”的缓存中找到类型引用指令“{0}”的解析。",
  "6242": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”。========",
  "6258": "应在 config json 文件的 “compilerOptions” 对象中设置 “{0}”",
  "6259": "在 {0} 中找到 1 个错误",
  "6260": "在同一文件中找到 {0} 个错误，起始位置为: {1}",
  "6261": "在 {1} 个文件中找到 {0} 个错误。",
  "6262": "文件名“{0}”具有“{1}”扩展 - 改为查找“{2}”。",
  "6263": "模块“{0}”已解析为“{1}”，但未设置“--allowArbitraryExtensions”。",
  "6266": "选项“{0}”只能在命令行上指定。",
  "6270": "目录 '{0}' 不包含 package.json 作用域。导入将无法解析。",
  "6271": "路径 '{1}' 处的 package.json 作用域中不存在导入说明符 '{0}'。",
  "6272": "无效的导入说明符 '{0}' 没有可行的解决方法。",
  "6273": "package.json 作用域 '{0}' 未定义导入。",
  "6274": "package.json 作用域 '{0}' 将说明符 '{1}' 显式映射到 NULL。",
  "6275": "package.json 作用域 '{0}' 的说明符 '{1}' 的目标类型无效",
  "6276": "路径 '{1}' 处的 package.json 作用域中不存在导出说明符 '{0}'。",
  "6278": "“{0}”处有类型，但在遵守 package.json \"exports\" 时无法解析此结果。“{1}”库可能需要更新其 package.json 或键入。",
  "6280": "“{0}”处有类型，但无法在当前 \"moduleResolution\" 设置下解析此结果。请考虑更新到 \"node16\"、\"nodenext\" 或 \"bundler\"。",
  "6282": "找到具有“{1}”版本的 peerDependency“{0}”。",
  "6283": "找不到 peerDependency“{0}”。",
  "6305": "未从源文件“{1}”生成输出文件“{0}”。",
  "6306": "引用的项目“{0}”必须拥有设置 \"composite\": true。",
  "6307": "文件 \"{0}\" 不在项目 \"{1}\" 的文件列表中。项目必须列出所有文件，或使用 \"include\" 模式。",
  "6310": "引用的项目“{0}”可能不会禁用发出。",
  "6350": "项目“{0}”已过期，因为输出“{1}”早于输入“{2}”",
  "6351": "项目“{0}”是最新的，因为最新的输入“{1}”早于输出“{2}”",
  "6352": "项目“{0}”已过期，因为输出文件“{1}”不存在",
  "6353": "项目“{0}”已过期，因为其依赖项“{1}”已过期",
  "6354": "项目“{0}”已是最新，拥有来自其依赖项的 .d.ts 文件",
  "6355": "此生成中的项目: {0}",
  "6356": "非 -dry 生成将删除以下文件: {0}",
  "6357": "非 -dry 生成将生成项目“{0}”",
  "6358": "正在生成项目“{0}”...",
  "6359": "正在更新项目“{0}”的输出时间戳...",
  "6361": "“{0}”项目已是最新",
  "6362": "正在跳过项目“{0}”的生成，因为其依赖项“{1}”有错误",
  "6363": "无法生成项目“{0}”，因为其依赖项“{1}”有错误",
  "6370": "选项“{0}”与“{1}”不能组合在一起。",
  "6371": "正在更新项目 \"{0}\" 未更改的输出时间戳…",
  "6374": "非 dry 生成将更新项目 '{0}' 的输出的时间戳",
  "6377": "无法写入文件 \"{0}\"，因为它将覆盖由引用的项目 \"{1}\" 生成的 \".tsbuildinfo\" 文件",
  "6381": "项目 \"{0}\" 已过期，因为其输出是使用与当前版本 \"{2}\" 不同的版本 \"{1}\" 生成的",
  "6382": "即将跳过项目 \"{0}\" 的生成，因为未生成其依赖项 \"{1}\"",
  "6383": "无法生成项目 \"{0}\" ，因为未生成其依赖项 \"{1}\"",
  "6385": "“{0}”已弃用。",
  "6387": "“{1}”的签名“{0}”已弃用。",
  "6388": "正在强制重新生成项目“{0}”",
  "6389": "正在重用旧程序“{1}”中模块“{0}”的解析，但其未解析。",
  "6390": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，已成功将其解析为“{2}”。",
  "6391": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，已成功将其解析为包 ID 为“{3}”的“{2}”。",
  "6392": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，但其未解析。",
  "6393": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，已成功将其解析为“{3}”。",
  "6394": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，已成功将其解析为包 ID 为“{4}”的“{3}”。",
  "6395": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，但其未解析。",
  "6396": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，已成功将其解析为“{3}”。",
  "6397": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，已成功将其解析为包 ID 为“{4}”的“{3}”。",
  "6398": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，但其未解析。",
  "6399": "项目“{0}”已过期，因为 buildinfo 文件“{1}”指示某些更改未发出",
  "6400": "项目“{0}”是最新的，但需要更新早于输入文件的输出文件的时间戳",
  "6401": "项目“{0}”已过期，因为读取文件“{1}”时出错",
  "6402": "正在 {0} 模式下解析，条件为 {1}。",
  "6403": "匹配的“{0}”条件“{1}”。",
  "6404": "将“{0}”子路径“{1}”与目标“{2}”一起使用",
  "6405": "看到了不匹配的条件“{0}”。",
  "6406": "由于 buildinfo 文件“{1}”指示 compilerOptions 中存在更改，因此项目“{0}”已过期",
  "6412": "由于 buildinfo 文件“{1}”指示文件“{2}”曾是编译的根文件，但不再是了，因此项目“{0}”已过期。",
  "6414": "已在条件“{0}”下解析。",
  "6415": "无法在条件“{0}”下解析。",
  "6417": "正在搜索所有上级 node_modules 目录以查找首选扩展: {0}。",
  "6418": "正在搜索所有上级 node_modules 目录以查找回退扩展: {0}。",
  "6419": "由于 buildinfo 文件“{1}”指示程序需要报告错误，因此项目“{0}”已过期。",
  "6420": "由于 {1}，项目“{0}”已过期。",
  "6500": "所需类型来自属性 \"{0}\"，在此处的 \"{1}\" 类型上声明该属性",
  "6504": "文件 \"{0}\" 是 JavaScript 文件。你是想启用 \"allowJs\" 选项吗?",
  "6807": "可以简化此操作。此班次与 `{0} {1} {2}` 相同。",
  "6913": "你可以在 {0} 了解编译器选项的所有内容",
  "6915": "使用 --build，-b 将使 tsc 的行为更像生成业务流程协调程序，而非编译器。这可用于触发生成复合项目，你可以在 {0} 详细了解这些项目",
  "7005": "变量“{0}”隐式具有“{1}”类型。",
  "7006": "参数“{0}”隐式具有“{1}”类型。",
  "7008": "成员“{0}”隐式包含类型“{1}”。",
  "7010": "缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。",
  "7011": "缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。",
  "7012": "此重载隐式返回类型“{0}”，因为它缺少返回类型批注。",
  "7014": "缺少返回类型注释的函数类型隐式具有 \"{0}\" 返回类型。",
  "7016": "无法找到模块“{0}”的声明文件。“{1}”隐式拥有 \"any\" 类型。",
  "7017": "元素隐式具有 \"any\" 类型，因为类型“{0}”没有索引签名。",
  "7018": "对象字面量的属性“{0}”隐式含有“{1}”类型。",
  "7019": "Rest 参数“{0}”隐式具有 \"any[]\" 类型。",
  "7022": "“{0}”隐式具有类型 \"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。",
  "7023": "由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "7025": "生成器隐式具有 yield 类型 ‘{0}’。请考虑提供一个返回类型注释。",
  "7026": "JSX 元素隐式具有类型 \"any\"，因为不存在接口 \"JSX.{0}\"。",
  "7031": "绑定元素“{0}”隐式具有“{1}”类型。",
  "7032": "属性“{0}”隐式具有类型 \"any\"，因为其 set 访问器缺少参数类型批注。",
  "7033": "属性“{0}”隐式具有类型 \"any\"，因为其 get 访问器缺少返回类型批注。",
  "7034": "变量“{0}”在某些无法确定其类型的位置处隐式具有类型“{1}”。",
  "7035": "尝试使用 `npm i --save-dev @types/{1}` (如果存在)，或者添加一个包含 `declare module '{0}';` 的新声明(.d.ts)文件",
  "7036": "动态导入的说明符类型必须是 \"string\"，但此处类型是 \"{0}\"。",
  "7040": "如果“{0}”包实际上公开此模块，请考虑发送拉取请求以修正“https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}”",
  "7042": "模块 \"{0}\" 已解析为 \"{1}\"，但未使用 \"--resolveJsonModule\"。",
  "7043": "变量 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7044": "参数 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7045": "成员 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7046": "变量 \"{0}\" 在某些位置隐式具有类型 \"{1}\"，但可以从使用情况推断出更好的类型。",
  "7047": "Rest 参数 \"{0}\" 隐式具有 \"any[]\" 类型，但可从用法中推断出更好的类型。",
  "7048": "属性 \"{0}\" 隐式具有类型 \"any\"，但可从用法为其 get 访问器推断出更好类型。",
  "7049": "属性 \"{0}\" 隐式具有类型 \"any\"，但可从用法为其 set 访问器推断出更好的类型。",
  "7050": "\"{0}\" 隐式具有 \"{1}\" 返回类型，但可以从用法中推断出更好的类型。",
  "7051": "参数具有名称，但不具有类型。你是想使用 \"{0}: {1}\" 吗?",
  "7052": "元素隐式具有 \"any\" 类型，因为类型 \"{0}\" 没有索引签名。你是想调用 \"{1}\" 吗?",
  "7053": "元素隐式具有 \"any\" 类型，因为类型为 \"{0}\" 的表达式不能用于索引类型 \"{1}\"。",
  "7054": "在类型 \"{1}\" 上找不到具有类型为 \"{0}\" 的参数的索引签名。",
  "7055": "缺少返回类型批注的 \"{0}\" 隐式具有 \"{1}\" 产出类型。",
  "7058": "如果“{0}”包实际公开了此模块，请尝试添加包含 `declare module‘{1}';` 的新声明(.d.ts)文件",
  "8006": "\"{0}\" 声明只能在 TypeScript 文件中使用。",
  "8009": "\"{0}\" 修饰符只能在 TypeScript 文件中使用。",
  "8022": "JSDoc \"@{0}\" 未附加到类。",
  "8023": "JSDoc \"@{0} {1}\" 不匹配 \"extends {2}\" 子句。",
  "8024": "JSDoc \"@param\" 标记具有名称 \"{0}\"，但不存在具有该名称的参数。",
  "8026": "应为 {0} 类型参数；请为这些参数添加 \"@extends\" 标记。",
  "8027": "应为 {0}-{1} 类型参数；请为这些参数添加 \"@extends\" 标记。",
  "8029": "JSDoc \"@param\" 标记的名称为“{0}”，但该名称没有参数。如果它为数组类型，将匹配 \"arguments\"。",
  "8032": "不允许使用限定名 \"{0}\"，因为没有前导 \"@param {object} {1}\"。",
  "9005": "此文件的声明发出要求使用专用名称 \"{0}\"。显式类型注释可能取消阻止声明发出。",
  "9006": "此文件的声明发出要求使用模块 \"{1}\" 中的专用名称 \"{0}\"。显式类型注释可能取消阻止声明发出。",
  "9027": "向变量 {0} 添加类型注释。",
  "9028": "向参数 {0} 添加类型注释。",
  "9029": "向属性 {0} 添加类型注释。",
  "9039": "包含专用名称“{0}”的类型不能与 --isolatedDeclarations 一起使用。",
  "17002": "“{0}”预期的相应 JSX 结束标记。",
  "17006": "乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。",
  "17008": "JSX 元素“{0}”没有相应的结束标记。",
  "17010": "未知类型获取选项“{0}”。",
  "17012": "“{0}”不是关键字“{1}”的有效元属性。是否是指“{2}”?",
  "17013": "元属性“{0}”只能在函数声明、函数表达式或构造函数的主体中使用。",
  "17018": "未知的类型获取选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "17019": "类型末尾的“{0}”不是有效的 TypeScript 语法。是否要写入“{1}”?",
  "17020": "类型开头的“{0}”不是有效的 TypeScript 语法。是否要写入“{1}”?",
  "18000": "解析配置时检测到循环: {0}",
  "18002": "配置文件“{0}”中的 \"files\" 列表为空。",
  "18003": "在配置文件“{0}”中找不到任何输入。指定的 \"include\" 路径为“{1}”，\"exclude\" 路径为“{2}”。",
  "18004": "速记属性 \"{0}\" 的范围内不存在任何值。请声明一个值或提供一个初始值设定项。",
  "18013": "属性 \"{0}\" 在类 \"{1}\" 外部不可访问，因为它具有专用标识符。",
  "18014": "无法在此类中的类型 \"{1}\" 上访问属性 \"{0}\"，因为具有相同拼写的另一个专用标识符隐藏了它。",
  "18015": "类型 \"{1}\" 中的属性 \"{0}\" 引用了不能从类型 \"{2}\" 内访问的其他成员。",
  "18017": "在此处定义了“{0}”的阴影声明",
  "18018": "你可能打算使用的 \"{0}\" 的声明在此处定义",
  "18019": "“{0}”修饰符不能与专用标识符一起使用。",
  "18027": "当发出专用标识符下层时，编译器会预留名称“{0}”。",
  "18031": "由于属性“{1}”在某些要素中具有存在冲突的类型，因此已将交集“{0}”缩减为“绝不”。",
  "18032": "由于属性“{1}”存在于多个要素中，但在某些要素中是专用属性，因此已将交集“{0}”缩减为“绝不”。",
  "18033": "根据计算枚举成员值的要求，类型“{0}”不能分配给类型“{1}”。",
  "18035": "\"jsxFragmentFactory\" 的值无效。“{0}”不是有效的标识符或限定名称。",
  "18039": "“{0}”的使用无效。它不能在类静态块内使用。",
  "18042": "“{0}”是一种类型，无法在 JavaScript 文件中导入。请在 JSDoc 类型批注中使用“{1}”。",
  "18044": "“{0}”自动导出到此处。",
  "18046": "“{0}”的类型为“未知”。",
  "18047": "“{0}”可能为 “null”。",
  "18048": "“{0}”可能为“未定义”。",
  "18049": "{0}可能为 “null” 或“未定义”。",
  "18050": "此处不能使用值“{0}”。",
  "18051": "无法为编译器选项“{0}”提供空字符串。",
  "18053": "其类型“{0}”不是有效的 JSX 元素类型。",
  "18055": "“{0}”具有字符串类型，但在启用 \"isolatedModules\" 时必须具有语法上可识别的字符串语法。",
  "18061": "“{0}”不是关键字 ‘import’ 的有效元属性。你是说 ‘meta’ 还是 ‘defer’?",
  "90004": "为 \"{0}\" 删除未使用的声明",
  "90005": "从“{0}”删除导入",
  "90006": "实现接口“{0}”",
  "90008": "将“{0}.”添加到未解析的变量",
  "90013": "从“{1}”导入“{0}”",
  "90014": "将“{0}”更改为“{1}”",
  "90016": "声明属性“{0}”",
  "90017": "为属性“{0}”添加索引签名",
  "90020": "初始化构造函数中的属性“{0}”",
  "90021": "初始化静态属性“{0}”",
  "90022": "将拼写更改为“{0}”",
  "90023": "声明方法“{0}”",
  "90024": "声明静态方法“{0}”",
  "90025": "带下划线的前缀“{0}”",
  "90026": "重写为索引访问类型“{0}”",
  "90027": "声明静态属性“{0}”",
  "90030": "将 \"infer {0}\" 替换为 \"unknown\"",
  "90035": "声明专用属性“{0}”",
  "90036": "将 \"{0}\" 替换为 \"Promise<{1}>\"",
  "90038": "声明私有方法 \"{0}\"",
  "90041": "为“{0}”删除未使用的声明",
  "90053": "声明名为 \"{0}\" 的专用字段。",
  "90054": "包含由“{0}”引用的类型的导入",
  "90055": "从“{0}”中删除导入声明中的“type”",
  "90056": "从“{1}”中删除“{0}”导入中的“type”",
  "90057": "从“{0}”添加导入",
  "90058": "从“{0}”更新导入",
  "90059": "从模块“{1}”导出“{0}”",
  "90061": "更新“{0}”的修饰符",
  "90062": "添加类型为“{0}”的注释",
  "90063": "添加返回类型“{0}”",
  "90068": "使用“{0}”添加 satisfies 和内联类型断言",
  "90069": "提取到变量并替换为“{0} 为 typeof {0}”",
  "95003": "将“{0}”转换为 {0} 中的 {1}",
  "95004": "提取到 {1} 中的 {0}",
  "95007": "提取到封闭范围中的 {0}",
  "95008": "提取到 {1} 范围中的 {0}",
  "95011": "根据使用情况推断“{0}”的类型",
  "95014": "安装“{0}”",
  "95015": "用“{0}”替换导入。",
  "95018": "向属性“{0}”添加 \"undefined\" 类型",
  "95019": "向属性“{0}”添加初始值设定项",
  "95020": "向属性“{0}”添加明确的赋值断言",
  "95055": "将“{0}”转换为映射对象类型",
  "95063": "添加缺少的枚举成员 \"{0}\"",
  "95080": "从用法中推断出 \"{0}\" 的 \"this\" 类型",
  "95084": "将 \"await\" 添加到 \"{0}\" 的初始值设定项",
  "95098": "将配置文件中的 \"target\" 选项设置为 \"{0}\"",
  "95099": "将配置文件中的 \"module\" 选项设置为 \"{0}\"",
  "95105": "将函数表达式 \"{0}\" 转换为箭头函数",
  "95106": "将函数声明“{0}”转换为箭头函数",
  "95138": "将每个误用的“{0}”切换到“{1}”",
  "95145": "对“{0}”使用元素访问",
  "95156": "添加缺少的函数声明 \"{0}\"",
  "95171": "删除未使用的 “@param” 标记“{0}”",
  "95173": "将 “@param” 标记名称“{0}”重命名为“{1}”",
  "95174": "使用 `{0}`",
  "95181": "使用 \"type {0}\"",
  "95187": "为对象成员完成“{0}”添加缺少的逗号。",
  "95188": "将缺少的参数添加到“{0}”",
  "95189": "将缺少的参数添加到“{0}”",
  "95191": "将可选参数添加到“{0}”",
  "95192": "将可选参数添加到“{0}”"
}