{
  "1002": "未终止的字符串字面量。",
  "1003": "应为标识符。",
  "1005": "应为“{0}”。",
  "1006": "文件不能引用自身。",
  "1007": "分析器预期在此处找到与“{0}”标记匹配的“{1}”。",
  "1009": "不允许使用尾随逗号。",
  "1010": "应为 \"*/\"。",
  "1011": "元素访问表达式应采用参数。",
  "1012": "意外的标记。",
  "1013": "Rest 参数或绑定模式不可带尾随逗号。",
  "1014": "rest 参数必须是参数列表中的最后一个参数。",
  "1015": "参数不能包含问号和初始化表达式。",
  "1016": "必选参数不能位于可选参数后。",
  "1017": "索引签名不能包含 rest 参数。",
  "1018": "索引签名参数不能具有可访问性修饰符。",
  "1019": "索引签名参数不能包含问号。",
  "1020": "索引签名参数不能具有初始化表达式。",
  "1021": "索引签名必须具有类型批注。",
  "1022": "索引签名参数必须具有类型批注。",
  "1024": "\"readonly\" 修饰符仅可出现在属性声明或索引签名中。",
  "1025": "索引签名不能包含尾随逗号。",
  "1028": "已看到可访问性修饰符。",
  "1029": "“{0}”修饰符必须位于“{1}”修饰符之前。",
  "1030": "已看到“{0}”修饰符。",
  "1031": "“{0}”修饰符不能出现在此类型的类元素上。",
  "1034": "\"super\" 的后面必须是参数列表或成员访问。",
  "1035": "仅环境模块可使用带引号的名称。",
  "1036": "不允许在环境上下文中使用语句。",
  "1038": "不能在已有的环境上下文中使用 \"declare\" 修饰符。",
  "1039": "不允许在环境上下文中使用初始化表达式。",
  "1040": "“{0}”修饰符不能在环境上下文中使用。",
  "1042": "“{0}”修饰符不能在此处使用。",
  "1044": "“{0}”修饰符不可出现在模块或命名空间元素上。",
  "1046": ".d.ts 文件中的顶级声明必须以 \"declare\" 或 \"export\" 修饰符开头。",
  "1047": "rest 参数不能为可选参数。",
  "1048": "rest 参数不能具有初始化表达式。",
  "1049": "\"set\" 访问器必须正好具有一个参数。",
  "1051": "\"set\" 访问器不能具有可选参数。",
  "1052": "\"set\" 访问器参数不能包含初始化表达式。",
  "1053": "\"set\" 访问器不能具有 rest 参数。",
  "1054": "\"get\" 访问器不能具有参数。",
  "1055": "类型“{0}”不是 ES5 中有效的异步函数返回类型，因为它不引用与 Promise 兼容的构造函数值。",
  "1056": "访问器仅在面向 ECMAScript 5 和更高版本时可用。",
  "1058": "异步函数的返回类型必须是有效承诺，或不得包含可调用的 \"then\" 成员。 ",
  "1059": "'Promise' 必须具有 'then' 方法。",
  "1060": "承诺的 \"then\" 方法的第一个参数必须是回调。",
  "1061": "枚举成员必须具有初始化表达式。",
  "1062": "类型在其自身的 \"then\" 方法的 fulfillment 回调中被直接或间接引用。",
  "1063": "不能在命名空间中使用导出分配。",
  "1064": "异步函数或方法的返回类型必须为全局 Promise<T> 类型。你是否是指写入 \"Promise<{0}>\"?",
  "1065": "异步函数或方法的返回类型必须为全局 Promise<T> 类型。",
  "1066": "在环境枚举声明中，成员初始化表达式必须是常数表达式。",
  "1068": "意外的标记。应为构造函数、方法、访问器或属性。",
  "1069": "意外的标记。类型参数名不应包含大括号。",
  "1070": "“{0}”修饰符不可出现在类型成员上。",
  "1071": "“{0}”修饰符不可出现在索引签名上。",
  "1079": "“{0}”修饰符不能与导入声明一起使用。",
  "1084": "\"reference\" 指令语法无效。",
  "1089": "“{0}”修饰符不能出现在构造函数声明中。",
  "1090": "“{0}”修饰符不能出现在参数中。",
  "1091": "\"for...in\" 语句中只允许单个变量声明。",
  "1092": "类型参数不能出现在构造函数声明中。",
  "1093": "类型批注不能出现在构造函数声明中。",
  "1094": "访问器不能具有类型参数。",
  "1095": "\"set\" 访问器不能具有返回类型批注。",
  "1096": "索引签名必须正好具有一个参数。",
  "1097": "“{0}”列表不能为空。",
  "1098": "类型参数列表不能为空。",
  "1099": "类型参数列表不能为空。",
  "1100": "严格模式下“{0}”的使用无效。",
  "1101": "严格模式下不允许使用 \"with\" 语句。",
  "1102": "在严格模式下，无法对标识符调用 \"delete\"。",
  "1103": "仅允许在异步函数和模块顶层使用“for await”循环。",
  "1104": "\"continue\" 语句只能在封闭迭代语句内使用。",
  "1105": "\"break\" 语句只能在封闭迭代或 switch 语句内使用。",
  "1106": "“for...of” 语句的左侧可能不是 “async”。",
  "1107": "跳转目标不能跨越函数边界。",
  "1108": "\"return\" 语句只能在函数体中使用。",
  "1109": "应为表达式。",
  "1110": "应为类型。",
  "1111": "必须在封闭类中声明私有字段“{0}”。",
  "1113": "\"default\" 子句在 \"switch\" 语句中只能出现一次。",
  "1114": "标签“{0}”重复。",
  "1115": "\"continue\" 语句只能跳转到封闭迭代语句的标签。",
  "1116": "\"break\" 语句只能跳转到封闭语句的标签。",
  "1117": "对象文本不能具有多个名称相同的属性。",
  "1118": "对象文字不能具有多个具有相同名称的 get/set 访问器。",
  "1119": "对象文字不能包含具有相同名称的属性和访问器。",
  "1120": "导出分配不能具有修饰符。",
  "1121": "不允许使用八进制文字。请使用语法“{0}”。",
  "1123": "变量声明列表不能为空。",
  "1124": "应为数字。",
  "1125": "应为十六进制数字。",
  "1126": "文本意外结束。",
  "1127": "无效的字符。",
  "1128": "应为声明或语句。",
  "1129": "应为语句。",
  "1130": "应为 \"case\" 或 \"default\"。",
  "1131": "应为属性或签名。",
  "1132": "应为枚举成员。",
  "1134": "应为变量声明。",
  "1135": "应为参数表达式。",
  "1136": "应为属性分配。",
  "1137": "应为表达式或逗号。",
  "1138": "应为参数声明。",
  "1139": "应为类型参数声明。",
  "1140": "应为类型参数。",
  "1141": "应为字符串字面量。",
  "1142": "不允许在此处换行。",
  "1144": "应为 \"{\" 或 \";\"。",
  "1145": "应为 “{” 或 JSX 元素。",
  "1146": "应为声明。",
  "1147": "命名空间中的导入声明不能引用模块。",
  "1148": "当 \"--module\" 为 \"none\" 时无法使用导入、导出或模块扩大。",
  "1149": "文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同。",
  "1155": "必须初始化“{0}”声明。",
  "1156": "“{0}”声明只能在块的内部声明。",
  "1160": "未终止的模板字面量。",
  "1161": "未终止的正则表达式字面量。",
  "1162": "对象成员无法声明为可选。",
  "1163": "只允许在生成器正文中使用 \"yield\" 表达式。",
  "1164": "枚举中不允许计算属性名。",
  "1165": "环境上下文中的计算属性名称必须引用类型为文本类型或 \"unique symbol\" 类型的表达式。",
  "1166": "类属性声明中的计算属性名称必须具有简单文本类型或“唯一符号”类型。",
  "1168": "方法重载中的计算属性名称必须引用文本类型或 \"unique symbol\" 类型的表达式。",
  "1169": "接口中的计算属性名称必须引用必须引用类型为文本类型或 \"unique symbol\" 的表达式。",
  "1170": "类型文本中的计算属性名称必须引用类型为文本类型或 \"unique symbol\" 类型的表达式。",
  "1171": "计算属性名中不允许逗号表达式。",
  "1172": "已看到 \"extends\" 子句。",
  "1173": "\"extends\" 子句必须位于 \"implements\" 子句之前。",
  "1174": "类只能扩展一个类。",
  "1175": "已看到 \"implements\" 子句。",
  "1176": "接口声明不能有 \"implements\" 子句。",
  "1177": "需要二进制数字。",
  "1178": "需要八进制数字。",
  "1179": "意外标记。应为 \"{\"。",
  "1180": "应为属性析构模式。",
  "1181": "应为数组元素析构模式。",
  "1182": "析构声明必须具有初始化表达式。",
  "1183": "不能在环境上下文中声明实现。",
  "1184": "修饰符不能出现在此处。",
  "1185": "遇到合并冲突标记。",
  "1186": "rest 元素不能具有初始化表达式。",
  "1187": "不能使用绑定模式声明参数属性。",
  "1188": "\"for...of\" 语句中只允许单个变量声明。",
  "1189": "\"for...in\" 语句的变量声明不能有初始化表达式。",
  "1190": "\"for...of\" 语句的变量声明不能有初始化表达式。",
  "1191": "导入声明不能有修饰符。",
  "1192": "模块“{0}”没有默认导出。",
  "1193": "导出声明不能有修饰符。",
  "1194": "命名空间中不允许有导出声明。",
  "1195": "\"export *\" 不会重新导出默认值。",
  "1196": "Catch 子句变量类型注释必须为 \"any\" 或 \"unknown\" (若已指定)。",
  "1197": "Catch 子句变量不能有初始化表达式。",
  "1198": "扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。",
  "1199": "未终止的 Unicode 转义序列。",
  "1200": "箭头前不允许有行终止符。",
  "1202": "面向 ECMAScript 模块时，不能使用导入分配。请考虑改用 \"import * as ns from \"mod\"\"、\"import {a} from \"mod\"\"、\"import d from \"mod\"\" 或另一种模块格式。",
  "1203": "面向 ECMAScript 模块时，不能使用导出分配。请考虑改用 \"export default\" 或另一种模块格式。",
  "1205": "启用“{0}”时重新导出类型需要使用“导出类型”。",
  "1206": "修饰器在此处无效。",
  "1207": "不能向多个同名的 get/set 访问器应用修饰器。",
  "1209": "新表达式中的可选链无效。是否要调用“{0}()”?",
  "1210": "类中包含的代码在 JavaScript 的严格模式下进行计算，该模式不允许以此方式使用“{0}”。有关详细信息，请参阅 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode。",
  "1211": "不带 \"default\" 修饰符的类声明必须具有名称。",
  "1212": "应为标识符。“{0}”在严格模式下是保留字。",
  "1213": "应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。",
  "1214": "应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。",
  "1215": "“{0}”的使用无效。模块自动处于严格模式。",
  "1216": "应为标识符。转换 ECMAScript 模块时，\"__esModule\" 保留为导出标记。",
  "1218": "当 \"--module\" 标志是 \"system\" 时不支持导出分配。",
  "1221": "不允许在环境上下文中使用生成器。",
  "1222": "重载签名无法声明为生成器。",
  "1223": "已指定“{0}”标记。",
  "1224": "签名“{0}”必须为类型谓词。",
  "1225": "找不到参数“{0}”。",
  "1226": "类型谓词“{0}”不可分配给“{1}”。",
  "1227": "参数“{0}”和参数“{1}”的位置不一样。",
  "1228": "只允许在函数和方法的返回类型位置使用类型谓词。",
  "1229": "类型谓词无法引用 rest 参数。",
  "1230": "类型谓词无法在绑定模式中引用元素“{0}”。",
  "1231": "导出分配必须位于文件或模块声明的顶层。",
  "1232": "导入声明只能在命名空间或模块的顶层使用。",
  "1233": "导出声明只能在命名空间或模块的顶层使用。",
  "1234": "只允许在文件的顶层中使用环境模块声明。",
  "1235": "命名空间声明只允许位于命名空间或模块的顶层。",
  "1236": "属性修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "1237": "参数修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "1238": "作为表达式调用时，无法解析类修饰器的签名。",
  "1239": "作为表达式调用时，无法解析参数修饰器的签名。",
  "1240": "作为表达式调用时，无法解析属性修饰器的签名。",
  "1241": "作为表达式调用时，无法解析方法修饰器的签名。",
  "1242": "\"abstract\" 修饰符仅可出现在类、方法或属性声明中。",
  "1243": "“{0}”修饰符不能与“{1}”修饰符一起使用。",
  "1244": "抽象方法只能出现在抽象类中。",
  "1245": "方法“{0}”不能具有实现，因为它标记为抽象。",
  "1246": "接口函数不能具有初始化表达式。",
  "1247": "类型文字数据不可具有初始化表达式。",
  "1248": "类成员不可具有“{0}”关键字。",
  "1249": "修饰器仅可修饰方法实现，而不可修饰重载。",
  "1250": "面向“ES5”时，在严格模式下，块内不允许函数声明。",
  "1251": "面向“ES5”时，在严格模式下，块内不允许函数声明。类定义自动处于严格模式。",
  "1252": "面向“ES5”时，在严格模式下，块内不允许函数声明。模块自动处于严格模式。",
  "1253": "抽象属性只能出现在抽象类中。",
  "1254": "环境上下文中的 \"const\" 初始化表达式必须为字符串、数字文本或文本枚举引用。",
  "1255": "此上下文中不允许明确的赋值断言 \"!\"。",
  "1257": "必选元素不能位于可选元素后。",
  "1258": "默认导出必须位于文件或模块声明的顶层。",
  "1259": "模块 \"{0}\" 只能在使用 \"{1}\" 标志时进行默认导入",
  "1260": "关键字不能包含转义字符。",
  "1261": "已包含的文件名 \"{0}\" 仅大小写与文件名 \"{1}\" 不同。",
  "1262": "应为标识符。“{0}”是模块顶层的预留字。",
  "1263": "具有初始值设定项的声明不能同时具有明确赋值断言。",
  "1264": "具有明确赋值断言的声明也必须具有类型批注。",
  "1265": "rest 元素不能跟在另一个 rest 元素之后。",
  "1266": "可选元素不能跟在 rest 元素之后。",
  "1267": "属性“{0}”不能具有初始化表达式，因为它标记为摘要。",
  "1268": "索引签名参数类型必须是 “string”、“number”、“symbol”或模板文本类型。",
  "1269": "启用“{0}”时，不能对类型或仅类型命名空间使用“export import”。",
  "1270": "装饰器函数返回类型“{0}”不可分配到类型“{1}”。",
  "1271": "装饰器函数返回类型为“{0}”，但预期为“void”或“any”。",
  "1272": "启用 “isolatedModules” 和 “emitDecoratorMetadata” 时，必须使用 “import type” 或命名空间导入来导入修饰签名中引用的类型。",
  "1273": "“{0}”修饰符不能出现在类型参数上",
  "1274": "“{0}”修饰符只能出现在类、接口或类型别名的类型参数上",
  "1275": "\"accessor\" 修饰符只能出现在属性声明中。",
  "1276": "\"accessor\" 属性不能声明为可选。",
  "1277": "“{0}”修饰符只能出现在函数、方法或类的类型参数上",
  "1278": "运行时将使用 {1} 个自变量调用修饰器，但修饰器需要 {0} 个。",
  "1279": "运行时将使用 {1} 个自变量调用修饰器，但修饰器至少需要 {0} 个。",
  "1280": "启用“{0}”时，全局脚本文件中不允许使用命名空间。如果此文件不是全局脚本，请将“moduleDetection”设置为“force”或添加空的“export {}”语句。",
  "1281": "启用“{1}”时，无法从没有限定的其他文件访问“{0}”。请改用“{2}”。",
  "1282": "启用“verbatimModuleSyntax”时，“export =”声明必须引用值，但“{0}”仅引用类型。",
  "1283": "启用“verbatimModuleSyntax”，但“{0}”解析为仅类型声明时，“export =”声明必须引用实际值。",
  "1284": "启用“verbatimModuleSyntax”时，“export default”必须引用一个值，但“{0}”只引用了一个类型。",
  "1285": "启用“verbatimModuleSyntax”，但“{0}”解析为仅类型声明时，“export default”必须引用实际值。",
  "1286": "启用“verbatimModuleSyntax”时，CommonJS 模块中不允许使用 ESM 语法。",
  "1287": "启用“verbatimModuleSyntax”时，不能对 CommonJS 模块中的值声明使用顶级“export”修饰符。",
  "1288": "启用“verbatimModuleSyntax”时，导入别名无法解析为类型或仅类型声明。",
  "1289": "“{0}”解析为仅类型声明，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用导入“{0}”的 \"import type\"。",
  "1290": "“{0}”解析为仅类型声明，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用 \"export type { {0} as default }\"。",
  "1291": "“{0}”解析为一个类型，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用导入“{0}”的 \"import type\"。",
  "1292": "“{0}”解析为一个类型，并且在启用“{1}”后重新导出之前，必须在此文件中标记为仅类型。请考虑使用 \"export type { {0} as default }\"。",
  "1293": "当“module”设置为“preserve”时，CommonJS 模块中不允许使用 ESM 语法。",
  "1294": "启用 “erasableSyntaxOnly” 时，不允许使用此语法。",
  "1300": "不允许在异步函数块中使用 \"with\" 语句。",
  "1308": "仅允许在异步函数和模块顶级使用 \"await\" 表达式。",
  "1309": "当前文件是 CommonJS 模块，因此不能在顶级使用 “await”。",
  "1312": "你的意思是使用 \":\" 吗? 当包含对象文字属于解构模式时，\"=\" 只能跟在属性名称的后面。",
  "1313": "\"if\" 语句的正文不能为空语句。",
  "1314": "全局模块导出仅可出现模块文件中。",
  "1315": "全局模块导出仅可出现声明文件中。",
  "1316": "全局模块导出仅可出现在顶层级别中。",
  "1317": "不能使用 rest 参数声明参数属性。",
  "1318": "抽象访问器不能有实现。",
  "1319": "默认导出只能在 ECMAScript-style 模块中使用。",
  "1320": "\"await\" 操作数的类型必须是有效承诺，或不得包含可调用的 \"then\" 成员。",
  "1321": "异步生成器中 \"yield\" 操作数的类型必须是有效承诺，或不得包含可调用的 \"then\" 成员。",
  "1322": "\"yield*\" 操作数的迭代元素的类型必须是有效承诺，或不得包含可调用的 \"then\" 成员。",
  "1323": "仅当将 ‘--module’ 标记设置为 ‘es2020’、‘es2022’、‘esnext’、‘commonjs’、‘amd’、‘system’、‘umd’、‘node16’、‘node18’、'node20' 或 ‘nodenext’ 时，才支持动态导入。",
  "1324": "仅当 ‘--module’ 选项设置为 ‘esnext’、‘node16’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’ 时，动态导入才支持第二个参数。",
  "1325": "动态导入的参数不能是扩展元素。",
  "1326": "“import” 的这种用法无效。可以写入 “import()” 调用，但它们必须具有括号，并且不能带有类型参数。",
  "1327": "应为带双引号的字符串字面量。",
  "1328": "属性值只能是字符串、数字、\"true\"、\"false\"、\"null\"、对象或数组等类型的字面量。",
  "1329": "“{0}”收到的参数过少，无法在此处充当修饰器。你是要先调用它，然后再写入 \"@{0}()\" 吗?",
  "1330": "类型为 \"unique symbol\" 的接口或类型文本的属性必须为 \"readonly\"。",
  "1331": "类型为 \"unique symbol\" 的类的属性必须同时为 \"static\" 和 \"readonly\"。",
  "1332": "类型为 \"unique symbol\" 的变量必须为 \"const\"。",
  "1333": "不可在具有绑定名称的变量声明中使用 \"unique symbol\" 类型。",
  "1334": "\"unique symbol\" 类型仅可用于变量语句中的变量。",
  "1335": "此处不允许使用 \"unique symbol\" 类型。",
  "1337": "索引签名参数类型不能为文本类型或泛型类型。请考虑改用映射的对象类型。",
  "1338": "仅条件类型的 \"extends\" 子句中才允许 \"infer\" 声明。",
  "1339": "模块“{0}”不引用值，但在此处用作值。",
  "1340": "模块 \"{0}\" 不引用类型，但在此处用作类型。你是想使用 \"typeof import('{0}')\" 吗?",
  "1341": "类构造函数可能不是访问器。",
  "1343": "仅当 '--module' 选项为 'es2020'、'es2022'、'esnext'、'system'、'node16'、'node18'、'node20' 或 'nodenext' 时，才允许使用 'import.meta' 元属性。",
  "1344": "此处不允许使用 'A 标签。",
  "1345": "无法测试 \"void\" 类型的表达式的真实性。",
  "1346": "此参数不允许与 \"use strict\" 指令一起使用。",
  "1347": "\"use strict\" 指令不能与非简单参数列表一起使用。",
  "1348": "此处声明了非简单参数。",
  "1349": "此处使用了 \"use strict\" 指令。",
  "1350": "打印最终配置而不是生成。",
  "1351": "标识符或关键字不能紧跟在数字字面量之后。",
  "1352": "BigInt 字面量中不能使用指数符号。",
  "1353": "BigInt 字面量必须是整数。",
  "1354": "仅允许对数组和元组字面量类型使用 \"readonly\" 类型修饰符。",
  "1355": "'const' 断言只能作用于枚举成员、字符串、数字、布尔值、数组或对象字面量。",
  "1356": "你是想将此函数标记为 \"async\" 吗?",
  "1357": "枚举成员名称的后面必须跟有 \",\"、\"=\" 或 \"}\"。",
  "1358": "可选链中不允许使用带有标记的模板表达式。",
  "1359": "应为标识符。\"{0}\" 是保留字，不能在此处使用。",
  "1360": "类型“{0}”不满足预期类型“{1}”。",
  "1361": "\"{0}\" 是使用 \"import type\" 导入的，因此不能用作值。",
  "1362": "\"{0}\" 是使用 \"export type\" 导出的，因此不能用作值。",
  "1363": "仅类型导入可以指定默认导入或命名绑定，但不能同时指定这两者。",
  "1364": "转换为仅类型导出",
  "1365": "将所有重新导出的类型转换为仅类型导出",
  "1366": "拆分为两个单独的导入声明",
  "1367": "拆分所有无效的仅类型导入",
  "1368": "类构造函数可能不是生成器。",
  "1369": "你是想使用 \"{0}\" 吗?",
  "1375": "仅当文件是模块时，才允许在该文件的顶层使用 \"await\" 表达式，但此文件没有导入或导出。请考虑添加空的 \"export {}\" 以将此文件变为模块。",
  "1376": "此处导入了 \"{0}\"。",
  "1377": "在此处导出了 \"{0}\"。",
  "1378": "仅当 ‘module’ 选项设置为 ‘es2022’、‘esnext’、‘system’、‘node16’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’，且 ‘target’ 选项设置为 ‘es2017’ 或更高版本时，才允许使用顶级 ‘await’ 表达式。",
  "1379": "导入别名不能引用使用 \"export type\" 导出的声明。",
  "1380": "导入别名不能引用使用 \"import type\" 导入的声明。",
  "1381": "意外的标记。你是想使用 `{'}'}` 还是 `&rbrace;`?",
  "1382": "意外的标记。你是想使用 `{'>'}` 还是 `&gt;`?",
  "1385": "在联合类型中使用时，函数类型标记必须用括号括起来。",
  "1386": "在联合类型中使用时，构造函数类型标记必须用括号括起来。",
  "1387": "在相交类型中使用时，函数类型标记必须用括号括起来。",
  "1388": "在相交类型中使用时，构造函数类型标记必须用括号括起来。",
  "1389": "“{0}”不得用作变量声明名称。",
  "1390": "不允许将 '{0}' 作为参数名。",
  "1392": "导入别名不能使用“导入类型”",
  "1393": "通过 {0} 从文件 \"{1}\" 导入",
  "1394": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入",
  "1395": "通过 {0} 从文件 \"{1}\" 导入，以按照 compilerOptions 中指定的配置导入 \"importHelpers\"",
  "1396": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入，以按照 compilerOptions 中指定的方式导入 \"importHelpers\"",
  "1397": "通过 {0} 从文件 \"{1}\" 导入，以导入 \"jsx\" 和 \"jsxs\" 工厂函数",
  "1398": "通过 {0} 从具有 packageId \"{2}\" 的文件 \"{1}\" 导入，以导入 \"jsx\" 和 \"jsxs\" 工厂函数",
  "1399": "在此处通过导入包含了文件。",
  "1400": "通过 \"{0}\" 从文件 \"{1}\" 引用",
  "1401": "在此处通过引用包含了文件。",
  "1402": "通过 \"{0}\" 从文件 \"{1}\" 引用了库类型",
  "1403": "通过 \"{0}\" 从具有 packageId \"{2}\" 的文件 \"{1}\" 引用了库类型",
  "1404": "在此处通过类型库引用包含了文件。",
  "1405": "通过 \"{0}\" 从文件 \"{1}\" 引用了库",
  "1406": "在此处通过库引用包含了文件。",
  "1407": "通过在 \"{1}\" 中的包含模式 \"{0}\" 匹配",
  "1408": "通过在此处指定包含模式匹配了文件。",
  "1409": "tsconfig.js 中 \"files\" 列表的一部分",
  "1410": "通过此处指定的“文件”列表匹配了文件。",
  "1411": "由于指定了 \"{1}\"，因此包含了引用的项目 \"{0}\" 的输出",
  "1412": "由于已将 \"--module\" 指定为 \"none\"，因此包含了引用的项目 \"{0}\" 的输出",
  "1413": "从此处指定的引用项目输出文件。",
  "1414": "由于指定了 \"{1}\"，因此包含了引用的项目 \"{0}\" 的源",
  "1415": "由于已将 \"--module\" 指定为 \"none\"，因此包含了引用的项目 \"{0}\" 的源",
  "1416": "文件源自此处指定的引用项目。",
  "1417": "在 compilerOptions 中指定的类型库 \"{0}\" 的入口点",
  "1418": "在 compilerOptions 中指定的类型库 \"{0}\" 的入口点，具有 packageId \"{1}\"",
  "1419": "文件是此处指定的类型库的入口点。",
  "1420": "隐式类型库 \"{0}\" 的入口点",
  "1421": "隐式类型库 \"{0}\" 的入口点，具有 packageId \"{1}\"",
  "1422": "CompilerOptions 中指定了库 \"{0}\"",
  "1423": "文件是此处指定的库。",
  "1424": "默认库",
  "1425": "目标 \"{0}\" 的默认库",
  "1426": "文件是此处指定的目标的默认库。",
  "1427": "为编译指定的根文件",
  "1428": "文件是项目引用源 \"{0}\" 的输出",
  "1429": "文件重定向到文件 \"{0}\"",
  "1430": "程序包含该文件是因为:",
  "1431": "仅当文件是模块且没有导入或导出项时，才允许在该文件的顶层使用“for await”循环。可考虑添加空的“export {}”将此文件变为模块。",
  "1432": "仅当 ‘module’ 选项设置为 ‘es2022’、‘esnext’、‘system’、‘node16’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’，且 ‘target’ 选项设置为 ‘es2017’ 或更高版本时，才允许使用顶级 ‘for await’ 循环。",
  "1433": "修饰器和修饰符都不能应用于“this”参数。",
  "1434": "意外的关键字或标识符。",
  "1435": "未知的关键字或标识符。你是不是指“{0}”?",
  "1436": "修饰器必须位于属性声明的名称和所有关键字之前。",
  "1437": "必须为命名空间指定名称。",
  "1438": "必须为接口指定名称。",
  "1439": "必须为类型别名指定名称。",
  "1440": "此位置不允许使用变量声明。",
  "1441": "无法在类型注释中启动函数调用。",
  "1442": "属性初始化表达式应有 \"=\"。",
  "1443": "模块声明名称只能使用 ' 或 \" 引用字符串。",
  "1448": "“{0}”解析为仅类型声明，并且在启用“{1}”时必须使用仅类型重新导出进行重新导出。",
  "1449": "保留 JavaScript 输出中未使用的导入值，否则将删除这些值。",
  "1450": "动态导入只能接受模块说明符和可选的特性集作为参数",
  "1451": "专用标识符仅允许在类主体中使用，并且只能用作类成员声明的一部分、属性访问或用在 \"in\" 表达式的左侧",
  "1453": "“resolution-mode”应为“require”或“import”。",
  "1454": "只能为仅类型导入设置 \"resolution-mode\"。",
  "1455": "\"resolution-mode\" 是类型导入断言的唯一有效密钥。",
  "1456": "类型导入断言应恰好有一个键 - \"resolution-mode\" - 值为 \"import\" 或 \"require\"。",
  "1457": "默认情况下匹配包括模式 “**/*”",
  "1458": "文件是 ECMAScript 模块，因为“{0}”具有值为 “module” 的字段 “type”",
  "1459": "文件是 CommonJS 模块，因为“{0}”具有值不是 “module” 的字段 “type”",
  "1460": "文件是 CommonJS 模块，因为“{0}”没有字段 “type”",
  "1461": "文件是 CommonJS 模块，因为找不到 “package.json”",
  "1463": "\"resolution-mode\" 是类型导入属性的唯一有效键。",
  "1464": "类型导入属性应只有一个键 \"resolution-mode\"，值为 \"import\" 或 \"require\"。",
  "1470": "将生成到 CommonJS 输出的文件中不允许 'import.meta' 元属性。",
  "1471": "无法使用此构造导入模块“{0}”。说明符仅解析为 ES 模块，后者不能使用“require”进行导入。请改用 ECMAScript 导入。",
  "1472": "应为 “catch” 或 “finally”。",
  "1473": "导入声明只能在模块的顶层使用。",
  "1474": "导出声明只能在模块的顶层使用。",
  "1475": "控制用于检测模块格式 JS 文件的方法。",
  "1476": "“auto”: 将带有导入、导出、import.meta、jsx (带有 jsx: react-jsx)或 esm 格式(带模块: node16+)的文件视为模块。",
  "1477": "实例化表达式不能后跟属性访问。",
  "1478": "应为标识符或字符串字面量。",
  "1479": "当前文件是 CommonJS 模块，其导入将生成“require”调用；但是，引用的文件是 ECMAScript 模块，它不能使用“require”进行导入。请考虑改为编写动态“import(\"{0}\")”调用。",
  "1480": "若要将此文件转换为 ECMAScript 模块，请将其文件扩展名更改为“{0}”，或者使用“{ \"type\": \"module\" }”创建本地 package.json 文件。",
  "1481": "若要将此文件转换为 ECMAScript 模块，请将其文件扩展名更改为“{0}”，或将字段“\"type\": \"module\"”添加到“{1}”。",
  "1482": "若要将此文件转换为 ECMAScript 模块，请将字段“\"type\": \"module\"”添加到“{0}”。",
  "1483": "若要将此文件转换为 ECMAScript 模块，请使用“{ \"type\": \"module\" }”创建本地 package.json 文件。",
  "1484": "“{0}”是一种类型，必须在启用 \"verbatimModuleSyntax\" 时使用仅类型导入进行导入。",
  "1485": "“{0}”解析为仅类型声明，并且必须在启用 \"verbatimModuleSyntax\" 时使用仅类型导入进行导入。",
  "1486": "此处“导出”之前使用的修饰器。",
  "1487": "不允许使用八进制转义序列。请使用语法“{0}”。",
  "1488": "不允许转义序列“{0}”。",
  "1489": "不允许使用带前导零的小数。",
  "1490": "文件似乎是二进制文件。",
  "1491": "“{0}”修饰符不能出现在 \"using\" 声明中。",
  "1492": "“{0}”声明可能没有绑定模式。",
  "1493": "\"for...in\" 语句的左侧不能是 \"using\" 声明。",
  "1494": "\"for...in\" 语句的左侧不能是 \"await using\" 声明。",
  "1495": "“{0}”修饰符不能出现在 \"await using\" 声明中。",
  "1496": "应为标识符、字符串文本或数字文本。",
  "1497": "表达式必须括在括号中才能用作修饰器。",
  "1498": "修饰器中的语法无效。",
  "1499": "未知的正则表达式标志。",
  "1500": "正则表达式标志重复。",
  "1501": "此正则表达式标志仅在面向“{0}”或更高版本时可用。",
  "1502": "不能同时设置 Unicode (u) 标志和 Unicode Sets (v) 标志。",
  "1503": "命名捕获组仅在面向“ES2018”或更高版本时可用。",
  "1504": "当有减号时，子空间标志必须存在。",
  "1505": "限定符不完整。应为数字。",
  "1506": "数字在限定符中顺序不对。",
  "1507": "没有可重复的内容。",
  "1508": "意外的“{0}”。你是否想要使用反斜杠对其进行转义?",
  "1509": "此正则表达式标志不能在子模式内切换。",
  "1510": "\"\\k\" 后面必须有一个括在尖括号中的捕获组名称。",
  "1511": "\"\\q\" 仅在字符类内可用。",
  "1512": "\"\\c\" 后面必须有一个 ASCII 字母。",
  "1513": "不确定的字符转义。",
  "1514": "应为捕获组名称。",
  "1515": "名称相同的命名捕获组必须彼此排斥。",
  "1516": "字符类范围不能由另一个字符类绑定。",
  "1517": "字符类中的范围顺序不对。",
  "1518": "可能匹配多个字符的任何内容在被否定的字符类中无效。",
  "1519": "运算符不得混合在字符类中。改为将其包装在嵌套类中。",
  "1520": "应为类集操作数。",
  "1521": "\"\\q\" 后面必须是括在大括号中的字符串替代项。",
  "1522": "字符类不得包含保留的双标点符号。你是否想要使用反斜杠对其进行转义?",
  "1523": "应为 Unicode 属性名称。",
  "1524": "未知的 Unicode 属性名称。",
  "1525": "应为 Unicode 属性值。",
  "1526": "未知的 Unicode 属性值。",
  "1527": "应为 Unicode 属性名称或值。",
  "1528": "任何可能匹配多个字符的 Unicode 属性仅在设置 Unicode Sets (v) 标志时可用。",
  "1529": "未知的 Unicode 属性名称或值。",
  "1530": "仅当设置了 Unicode (u) 标志或 Unicode Sets (v) 标志时，Unicode 属性值表达式才可用。",
  "1531": "“\\{0}”后面必须是括在大括号中的 Unicode 属性值表达式。",
  "1532": "此正则表达式中没有名为“{0}”的捕获组。",
  "1533": "此向后引用指的是一个不存在的组。此正则表达式中只有 {0} 个捕获组。",
  "1534": "此向后引用指的是一个不存在的组。此正则表达式中没有捕获组。",
  "1535": "不能在正则表达式中转义此字符。",
  "1536": "字符类中不允许使用八进制转义序列和反向引用。如果这是转义序列，请改用语法“{0}”。",
  "1537": "字符类中不允许使用十进制转义序列和反向引用。",
  "1538": "仅当设置了 Unicode (u) 标志或 Unicode Sets (v) 标志时，Unicode 转义序列才可用。",
  "1539": "“bigint”文本不能用作属性名称。",
  "1540": "不应使用 \"module\" 关键字声明 \"namespace\" 声明。请改用 \"namespace\" 关键字。",
  "1541": "从 CommonJS 模块导入 ECMAScript 模块的仅类型导入必须具有 \"resolution-mode\" 属性。",
  "1542": "从 CommonJS 模块导入 ECMAScript 模块的类型导入必须具有 \"resolution-mode\" 属性。",
  "1543": "当 ‘module’ 设置为 ‘{0}’ 时，将 JSON 文件导入 ECMAScript 模块需要 ‘type: “json”’ 导入属性。",
  "1544": "当 ‘module’ 设置为 ‘{0}’ 时，不允许从 JSON 文件到 ECMAScript 模块中的命名导入。",
  "1545": "环境上下文中不允许使用 ‘using’ 声明。",
  "1546": "环境上下文中不允许使用 ‘await using’ 声明。",
  "2200": "在这些类型中，\"{0}\" 的类型不兼容。",
  "2201": "在这些类型中，\"{0}\" 返回的类型不兼容。",
  "2202": "调用签名返回类型 \"{0}\" 和 \"{1}\" 不兼容。",
  "2203": "构造签名返回类型 \"{0}\" 和 \"{1}\" 不兼容。",
  "2204": "没有参数的调用签名具有不兼容的返回类型 \"{0}\" 和 \"{1}\"。",
  "2205": "不带参数的构造签名具有不兼容的返回类型 \"{0}\" 和 \"{1}\"。",
  "2206": "在将 “import type” 用在其导入语句上时，不能在已命名导入上使用 “type” 修饰符。。",
  "2207": "在将 “export type” 用在其导出语句上时，不能在已命名导出上使用 “type” 修饰符。",
  "2208": "此类型参数可能需要 `extends {0}` 约束。",
  "2209": "项目根不明确，但需要解析文件“{1}”中的导出映射项“{0}”。提供 `rootDir` 编译器选项以消除歧义。",
  "2210": "项目根不明确，但仍需要解析文件“{1}”中的导入映射项“{0}”。提供 `rootDir` 编译器选项以消除歧义。",
  "2211": "添加 `extends` 约束。",
  "2212": "将 `extends` 约束添加到所有类型参数",
  "2300": "标识符“{0}”重复。",
  "2301": "实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。",
  "2302": "静态成员不能引用类类型参数。",
  "2303": "导入别名“{0}”的循环定义。",
  "2304": "找不到名称“{0}”。",
  "2305": "模块“{0}”没有导出的成员“{1}”。",
  "2306": "文件“{0}”不是模块。",
  "2307": "找不到模块“{0}”或其相应的类型声明。",
  "2308": "模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。",
  "2309": "不能在具有其他导出元素的模块中使用导出分配。",
  "2310": "类型“{0}”以递归方式将自身引用为基类。",
  "2311": "找不到名称“{0}”。你是否要在异步函数中写入此内容?",
  "2312": "接口只能扩展使用静态已知成员的对象类型或对象类型的交集。",
  "2313": "类型参数“{0}”具有循环约束。",
  "2314": "泛型类型“{0}”需要 {1} 个类型参数。",
  "2315": "类型“{0}”不是泛型类型。",
  "2316": "全局类型“{0}”必须为类或接口类型。",
  "2317": "全局类型“{0}”必须具有 {1} 个类型参数。",
  "2318": "找不到全局类型“{0}”。",
  "2319": "“{1}”和“{2}”类型的命名属性“{0}”不完全相同。",
  "2320": "接口“{0}”不能同时扩展类型“{1}”和“{2}”。",
  "2321": "与类型“{0}”和“{1}”相比，堆栈深度过高。",
  "2322": "不能将类型“{0}”分配给类型“{1}”。",
  "2323": "无法重新声明导出的变量“{0}”。",
  "2324": "类型“{1}”中缺少属性“{0}”。",
  "2325": "属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。",
  "2326": "属性“{0}”的类型不兼容。",
  "2327": "属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。",
  "2328": "参数“{0}”和“{1}” 的类型不兼容。",
  "2329": "类型“{1}”中缺少类型“{0}”的索引签名。",
  "2330": "“{0}”和“{1}”索引签名不兼容。",
  "2331": "不能在模块或命名空间体中引用 \"this\"。",
  "2332": "不能在当前位置引用 \"this\"。",
  "2334": "不能在静态属性初始化表达式中引用 \"this\"。",
  "2335": "只能在派生类中引用 \"super\"。",
  "2336": "不能在构造函数参数中引用 \"super\"。",
  "2337": "不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。",
  "2338": "只有构造函数、成员函数或派生类的成员访问器中才允许 \"super\" 属性访问。",
  "2339": "类型“{1}”上不存在属性“{0}”。",
  "2340": "通过 \"super\" 关键字只能访问基类的公共方法和受保护方法。",
  "2341": "属性“{0}”为私有属性，只能在类“{1}”中访问。",
  "2343": "此语法需要名为 \"{1}\" 的导入帮助器，\"{0}\" 中不存在该帮助器。请考虑升级 \"{0}\" 的版本。",
  "2344": "类型“{0}”不满足约束“{1}”。",
  "2345": "类型“{0}”的参数不能赋给类型“{1}”的参数。",
  "2346": "调用目标不包含任何签名。",
  "2347": "非类型化函数调用不能接受类型参数。",
  "2348": "类型“{0}”的值不可调用。是否希望包括 \"new\"?",
  "2349": "此表达式不可调用。",
  "2350": "使用 \"new\" 关键字只能调用 void 函数。",
  "2351": "此表达式不可构造。",
  "2352": "类型 \"{0}\" 到类型 \"{1}\" 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 \"unknown\"。",
  "2353": "对象字面量只能指定已知属性，并且“{0}”不在类型“{1}”中。",
  "2354": "此语法需要一个导入的帮助程序，但找不到模块“{0}”。",
  "2355": "其声明类型不为 \"undefined\"、\"void\" 或 \"any\" 的函数必须返回值。",
  "2356": "算术操作数必须为类型 \"any\"、\"number\"、\"bigint\" 或枚举类型。",
  "2357": "递增或递减运算符的操作数必须是变量或属性访问。",
  "2358": "\"instanceof\" 表达式左侧必须是 \"any\" 类型、对象类型或类型参数。",
  "2359": "\"instanceof\" 表达式的右侧必须是类型 \"any\"、类、函数或其他可分配给 \"Function\" 接口类型的类型，或者是具有 \"Symbol.hasInstance\" 方法的对象类型。",
  "2362": "算术运算左侧必须是 \"any\"、\"number\"、\"bigint\" 或枚举类型。",
  "2363": "算术运算右侧必须是 \"any\"、\"number\"、\"bigint\" 或枚举类型。",
  "2364": "赋值表达式的左侧必须是变量或属性访问。",
  "2365": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
  "2366": "函数缺少结束 return 语句，返回类型不包括 \"undefined\"。",
  "2367": "此比较似乎是无意的，因为类型“{0}”和“{1}”没有重叠。",
  "2368": "类型参数名称不能为“{0}”。",
  "2369": "只允许在构造函数实现中使用参数属性。",
  "2370": "rest 参数必须是数组类型。",
  "2371": "只允许在函数或构造函数实现中使用参数初始化表达式。",
  "2372": "参数“{0}”不能引用它自身。",
  "2373": "参数“{0}”不能引用在它之后声明的标识符“{1}”。",
  "2374": "类型“{0}”的索引签名重复。",
  "2375": "类型 “{0}” 不能分配给“exactOptionalPropertyTypes: true”的类型 “{1}”。请考虑将 “undefined” 添加到目标属性的类型。",
  "2376": "当派生类包含初始化属性、参数属性或专用标识符时，“super” 调用必须是构造函数中用来引用 “super” 或 “this” 的第一个语句。",
  "2377": "派生类的构造函数必须包含 \"super\" 调用。",
  "2378": "\"get\" 访问器必须返回值。",
  "2379": "类型为“{0}”的参数不能分配给类型为“{1}”且 “exactOptionalPropertyTypes: true” 的参数。请考虑将 “undefined” 添加到目标属性的类型。",
  "2383": "重载签名必须均导出或均不导出。",
  "2384": "重载签名必须全部为环境签名或非环境签名。",
  "2385": "重载签名必须全部是公共签名、私有签名或受保护签名。",
  "2386": "重载签名必须全部为可选签名或必需签名。",
  "2387": "函数重载必须为静态。",
  "2388": "函数重载不能为静态。",
  "2389": "函数实现名称必须为“{0}”。",
  "2390": "缺少构造函数实现。",
  "2391": "函数实现缺失或未立即出现在声明之后。",
  "2392": "不允许存在多个构造函数实现。",
  "2393": "函数实现重复。",
  "2394": "此重载签名与其实现签名不兼容。",
  "2395": "合并声明“{0}”中的单独声明必须全为导出或全为局部声明。",
  "2396": "标识符 \"arguments\" 重复。编译器使用 \"arguments\" 初始化 rest 参数。",
  "2397": "声明名称与内置全局标识符“{0}”冲突。",
  "2398": "“构造函数”不能用作参数属性名称。",
  "2399": "标识符 \"_this\" 重复。编译器使用变量声明 \"_this\" 来捕获 \"this\" 引用。",
  "2400": "表达式解析为编译器用于捕获 \"this\" 引用的变量声明 \"_this\"。",
  "2401": "“super” 调用必须是包含初始化属性、参数属性或专用标识符的派生类的构造函数中的根级语句。",
  "2402": "表达式解析为 \"_super\"，编译器使用 \"_super\" 获取基类引用。",
  "2403": "后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
  "2404": "\"for...in\" 语句的左侧不能使用类型批注。",
  "2405": "\"for...in\" 语句的左侧必须是 \"string\" 或 \"any\" 类型。",
  "2406": "\"for...in\" 语句的左侧必须是变量或属性访问。",
  "2407": "\"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数，但此处的类型为“{0}”。",
  "2408": "Setter 不能返回值。",
  "2409": "构造函数签名的返回类型必须可赋给类的实例类型。",
  "2410": "不支持 \"with\" 语句。\"with\" 程序块中的所有符号都将具有类型 \"any\"。",
  "2411": "类型“{1}”的属性“{0}”不能赋给“{2}”索引类型“{3}”。",
  "2412": "类型 “{0}” 不能分配给“exactOptionalPropertyTypes: true”的类型 “{1}”。请考虑将 “undefined” 添加到目标类型。。",
  "2413": "“{0}”索引类型“{1}”不能分配给“{2}”索引类型“{3}”。",
  "2414": "类名不能为“{0}”。",
  "2415": "类“{0}”错误扩展基类“{1}”。",
  "2416": "类型“{1}”中的属性“{0}”不可分配给基类型“{2}”中的同一属性。",
  "2417": "类静态侧“{0}”错误扩展基类静态侧“{1}”。",
  "2418": "计算属性类型的值为 \"{0}\"，该值不能赋给 \"{1}\" 类型。",
  "2419": "构造签名的类型不兼容。",
  "2420": "类“{0}”错误实现接口“{1}”。",
  "2422": "类只能实现具有静态已知成员的对象类型或对象类型的交集。",
  "2423": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
  "2425": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
  "2426": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
  "2427": "接口名称不能为“{0}”。",
  "2428": "“{0}”的所有声明都必须具有相同的类型参数。",
  "2430": "接口“{0}”错误扩展接口“{1}”。",
  "2431": "枚举名不能为“{0}”。",
  "2432": "在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。",
  "2433": "命名空间声明必须位于与之合并的类或函数所在的相同文件内。",
  "2434": "命名空间声明不能位于与之合并的类或函数前",
  "2435": "环境模块不能嵌套在其他模块或命名空间中。",
  "2436": "环境模块声明无法指定相对模块名。",
  "2437": "模块“{0}”被具有相同名称的局部声明隐藏。",
  "2438": "导入名称不能为“{0}”。",
  "2439": "环境模块声明中的导入或导出声明不能通过相对模块名引用模块。",
  "2440": "导入声明与“{0}”的局部声明冲突。",
  "2441": "标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。",
  "2442": "类型具有私有属性“{0}”的单独声明。",
  "2443": "属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。",
  "2444": "属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。",
  "2445": "属性“{0}”受保护，只能在类“{1}”及其子类中访问。",
  "2446": "属性“{0}”受保护，只能通过类“{1}”的实例进行访问。这是类“{2}”的实例。",
  "2447": "“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。",
  "2448": "声明之前已使用的块范围变量“{0}”。",
  "2449": "类“{0}”用于其声明前。",
  "2450": "枚举“{0}”用于其声明前。",
  "2451": "无法重新声明块范围变量“{0}”。",
  "2452": "枚举成员不能具有数值名。",
  "2454": "在赋值前使用了变量“{0}”。",
  "2456": "类型别名“{0}”循环引用自身。",
  "2457": "类型别名不能为“{0}”。",
  "2458": "AMD 模块无法拥有多个名称分配。",
  "2459": "模块 \"{0}\" 在本地声明 \"{1}\"，但未导出它。",
  "2460": "模块 \"{0}\" 在本地声明 \"{1}\"，但它被导出为 \"{2}\"。",
  "2461": "类型“{0}”不是数组类型。",
  "2462": "rest 元素必须在析构模式中位于最末。",
  "2463": "绑定模式参数在实现签名中不能为可选参数。",
  "2464": "计算属性名的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。",
  "2465": "不能在计算属性名中引用 \"this\"。",
  "2466": "不能在计算属性名中引用 \"super\"。",
  "2467": "计算属性名无法从其包含的类型引用类型参数。",
  "2468": "找不到全局值“{0}”。",
  "2469": "“{0}”运算符不能应用于类型 \"symbol\"。",
  "2472": "仅当面向 ECMAScript 5 和更高版本时，\"new\" 表达式中的展开运算符才可用。",
  "2473": "枚举声明必须全为常数或非常数。",
  "2474": "const 枚举成员初始值设定项必须是常量表达式。",
  "2475": "\"const\" 枚举仅可在属性、索引访问表达式、导入声明的右侧、导出分配或类型查询中使用。",
  "2476": "只有使用字符串文本才能访问常数枚举成员。",
  "2477": "\"const\" 枚举成员初始化表达式的求值结果为非有限值。",
  "2478": "\"const\" 枚举成员初始化表达式的求值结果为不允许使用的值 \"NaN\"。",
  "2480": "\"let\" 不能用作 \"let\" 或 \"const\" 声明中的名称。",
  "2481": "无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。",
  "2483": "\"for...of\" 语句的左侧不能使用类型批注。",
  "2484": "导出声明与“{0}”的导出声明冲突。",
  "2487": "\"for...of\" 语句的左侧必须是变量或属性访问。",
  "2488": "类型“{0}”必须具有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2489": "迭代器必须具有 \"next()\" 方法。",
  "2490": "迭代器的 \"{0}()\" 方法返回的类型必须具有 \"value\" 属性。",
  "2491": "\"for...in\" 语句的左侧不能为析构模式。",
  "2492": "无法在 catch 子句中重新声明标识符“{0}”。",
  "2493": "长度为 \"{1}\" 的元组类型 \"{0}\" 在索引 \"{2}\" 处没有元素。",
  "2494": "仅 ECMAScript 5 和更高版本支持在 \"for...of\" 语句中使用字符串。",
  "2495": "类型“{0}”不是数组类型或字符串类型。",
  "2496": "无法在 ES5 中的箭头函数中引用 \"arguments\" 对象。请考虑使用标准函数表达式。",
  "2497": "只能通过启用 \"{0}\" 标志并引用其默认导出，使用 ECMAScript 导入/导出来引用此模块。",
  "2498": "模块“{0}”使用 \"export =\" 且无法与 \"export *\" 一起使用。",
  "2499": "接口只能扩展具有可选类型参数的标识符/限定名称。",
  "2500": "类只能实现具有可选类型参数的标识符/限定名称。",
  "2501": "rest 元素不能包含绑定模式。",
  "2502": "“{0}”在其自身的类型批注中得到直接或间接引用。",
  "2503": "找不到命名空间“{0}”。",
  "2504": "类型“{0}”必须具有返回异步迭代器的 \"[Symbol.asyncIterator]()\" 方法。",
  "2505": "生成器不能具有 \"void\" 类型批注。",
  "2506": "“{0}”在其自身的基表达式中得到直接或间接引用。",
  "2507": "类型“{0}”不是构造函数类型。",
  "2508": "没有任何基构造函数具有指定数量的类型参数。",
  "2509": "基构造函数返回类型 \"{0}\" 不是具有静态已知成员的对象类型或对象类型的交集。",
  "2510": "所有的基构造函数必须具有相同的返回类型。",
  "2511": "无法创建抽象类的实例。",
  "2512": "重载签名必须都是抽象的或都是非抽象的。",
  "2513": "无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。",
  "2514": "不能使用负值为元组类型编制索引。",
  "2515": "非抽象类“{0}”不会实现继承自“{2}”类的抽象成员 {1}。",
  "2516": "抽象方法的所有声明必须是连续的。",
  "2517": "无法将抽象构造函数类型分配给非抽象构造函数类型。",
  "2518": "基于 \"this\" 的类型防护与基于参数的类型防护不兼容。",
  "2519": "异步迭代器必须具有 \"next()\" 方法。",
  "2520": "标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。",
  "2522": "无法在 ES5 中的异步函数或方法中引用 \"arguments\" 对象。请考虑使用标准函数或方法。",
  "2523": "不能在参数初始化表达式中使用 \"yield\" 表达式。",
  "2524": "不能在参数初始化表达式中使用 \"await\" 表达式。",
  "2526": "\"this\" 类型仅在类或接口的非静态成员中可用。",
  "2527": "“{0}”的推断类型引用不可访问的“{1}”类型。需要类型批注。",
  "2528": "一个模块不能具有多个默认导出。",
  "2529": "标识符“{0}”重复。编译器在包含异步函数的模块的顶层范围中保留名称“{1}”。",
  "2530": "属性“{0}”与索引签名不兼容。",
  "2531": "对象可能为 \"null\"。",
  "2532": "对象可能为“未定义”。",
  "2533": "对象可能为 \"null\" 或“未定义”。",
  "2534": "返回“从不”的函数不能具有可访问的终结点。",
  "2536": "类型“{0}”无法用于索引类型“{1}”。",
  "2537": "类型“{0}”没有匹配的类型“{1}”的索引签名。",
  "2538": "类型“{0}”不能作为索引类型使用。",
  "2539": "无法为“{0}”赋值，因为它不是变量。",
  "2540": "无法为“{0}”赋值，因为它是只读属性。",
  "2542": "类型“{0}”中的索引签名仅允许读取。",
  "2543": "标识符 \"_newTarget\" 重复。编译器使用变量声明 \"_newTarget\" 来捕获 \"new.target\" 元属性引用。",
  "2544": "表达式解析为编辑器用于捕获 \"new.target\" 元属性引用的变量声明 \"_newTarget\"。",
  "2545": "mixin 类必须具有单个 rest 参数为类型 \"any[]\" 的构造函数。",
  "2547": "异步迭代器的 \"{0}()\" 方法返回的类型必须是具有 \"value\" 属性的类型的承诺。",
  "2548": "类型“{0}”不是数组类型，或者没有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2549": "类型“{0}”不是数组类型或字符串类型，或者没有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "2550": "属性“{0}”在类型“{1}”上不存在。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为“{2}”或更高版本。",
  "2551": "属性“{0}”在类型“{1}”上不存在。你是否指的是“{2}”?",
  "2552": "找不到名称“{0}”。你是否指的是“{1}”?",
  "2553": "含字符串值成员的枚举中不允许使用计算值。",
  "2554": "应有 {0} 个参数，但获得 {1} 个。",
  "2555": "应有至少 {0} 个参数，但获得 {1} 个。",
  "2556": "扩张参数必须具有元组类型或传递给 rest 参数。",
  "2558": "应有 {0} 个类型参数，但获得 {1} 个。",
  "2559": "类型“{0}”与类型“{1}”不具有相同的属性。",
  "2560": "类型“{0}”的值没有与类型“{1}”相同的属性。你是想调用它吗?",
  "2561": "对象字面量只能指定已知的属性，但“{0}”中不存在类型“{1}”。是否要写入 {2}?",
  "2562": "基类表达式无法引用类类型参数。",
  "2563": "包含函数或模块体对于控制流分析而言太大。",
  "2564": "属性“{0}”没有初始化表达式，且未在构造函数中明确赋值。",
  "2565": "在赋值前使用了属性“{0}”。",
  "2566": "其余元素不能具有属性名。",
  "2567": "枚举声明只能与命名空间或其他枚举声明合并。",
  "2568": "类型“{1}”上不存在属性“{0}”。你是否是指“{2}”?",
  "2570": "找不到名称“{0}”。你是否是指“{1}”?",
  "2571": "对象的类型为 \"unknown\"。",
  "2574": "rest 元素类型必须是数组类型。",
  "2575": "没有需要 {0} 参数的重载，但存在需要 {1} 或 {2} 参数的重载。",
  "2576": "属性“{0}”在类型“{1}”上不存在。你的意思是改为访问静态成员“{2}”吗?",
  "2577": "返回类型注释循环引用自身。",
  "2578": "未使用的 \"@ts-expect-error\" 指令。",
  "2580": "找不到名称“{0}”。是否需要安装 Node.js 的类型定义? 请尝试运行 `npm i --save-dev @types/node`。",
  "2581": "找不到名称 \"{0}\"。是否需要安装 jQuery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`。",
  "2582": "找不到名称 \"{0}\"。是否需要安装测试运行器的类型定义? 请尝试使用 `npm i --save-dev @types/jest` 或 `npm i --save-dev @types/mocha`。",
  "2583": "找不到名称“{0}”。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为“{1}”或更高版本。",
  "2584": "找不到名称“{0}”。是否需要更改目标库? 请尝试更改 “lib” 编译器选项以包括 “dom”。",
  "2585": "“{0}” 仅指类型，但在此处用作值。是否需要更改目标库? 请尝试将 “lib” 编译器选项更改为 es2015 或更高版本。",
  "2588": "无法分配到 \"{0}\" ，因为它是常数。",
  "2589": "类型实例化过深，且可能无限。",
  "2590": "表达式生成的联合类型过于复杂，无法表示。",
  "2591": "找不到名称“{0}”。是否需要安装 Node.js 的类型定义? 请尝试运行 `npm i --save-dev @types/node`，然后将 \"node\" 添加到 tsconfig 的 types 字段。",
  "2592": "找不到名称“{0}”。是否需要安装 jQuery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`，然后将 “jquery” 添加到 teconfig 中的类型字段。",
  "2593": "找不到名称“{0}”。是否需要安装测试运行器的类型定义? 请尝试使用 `npm i --save-dev @types/jest` 或 `npm i --save-dev @types/mocha`，然后将 “jest” 或 “mocha” 添加到 tsconfig 中的类型字段。。",
  "2594": "此模块是使用 “export =” 声明的，只能在使用“{0}”标志时用于默认导入。",
  "2595": "仅可使用默认导入来导入“{0}”。",
  "2596": "只能通过启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2597": "只能使用 \"require\" 调用或使用默认导入来导入“{0}”。",
  "2598": "只能通过使用 \"require\" 调用或启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2602": "JSX 元素隐式具有类型 \"any\"，因为不存在全局类型 \"JSX.Element\"。",
  "2603": "类型“{1}”中的属性“{0}”不可分配给类型“{2}”。",
  "2604": "JSX 元素类型“{0}”不具有任何构造签名或调用签名。",
  "2606": "JSX 展开特性的“{0}”属性不能分配给目标属性。",
  "2607": "JSX 元素类不支持特性，因为它不具有“{0}”属性。",
  "2608": "全局类型 \"JSX.{0}\" 不可具有多个属性。",
  "2609": "JSX 扩展子属性必须为数组类型。",
  "2610": "\"{0}\" 在类 \"{1}\" 中定义为访问器，但这里在 \"{2}\" 中重写为实例属性。",
  "2611": "\"{0}\" 在类 \"{1}\" 中定义为属性，但这里在 \"{2}\" 中重写为访问器。",
  "2612": "属性 \"{0}\" 将覆盖 \"{1}\" 中的基属性。如果是有意的，请添加初始值设定项。否则，请添加 \"declare\" 修饰符或删除多余的声明。",
  "2613": "模块 \"{0}\" 没有默认导出。你是想改为使用 \"import { {1} } from {0}\" 吗?",
  "2614": "模块 \"{0}\" 没有导出的成员 \"{1}\"。你是想改用 \"import {1} from {0}\" 吗?",
  "2615": "属性“{0}”的类型在已映射的类型“{1}”中循环引用其自身。",
  "2616": "仅可使用 \"import {1} = require({2})\" 或默认导入来导入“{0}”。",
  "2617": "仅可使用 \"import {1} = require({2})\" 或通过启用 \"esModuleInterop\" 标志并使用默认导入来导入“{0}”。",
  "2618": "源具有 {0} 个元素，但目标需要 {1} 个。",
  "2619": "源具有 {0} 个元素，但目标仅允许 {1} 个。",
  "2620": "目标仅允许 {0} 个元素，但源中的元素可能不够。",
  "2621": "目标仅允许 {0} 个元素，但源中的元素可能更多。",
  "2623": "源不提供目标中位置 {0} 处所需元素的匹配项。",
  "2624": "源不提供目标中位置 {0} 处可变元素的匹配项。",
  "2625": "源中位置 {0} 的可变元素与目标中位置 {1} 的元素不匹配。",
  "2626": "源中位置 {0} 的类型与目标中位置 {1} 的类型不兼容。",
  "2627": "源中位置 {0} 到 {1} 的类型与目标中位置 {2} 的类型不兼容。",
  "2628": "无法为“{0}”赋值，因为它是枚举。",
  "2629": "无法为“{0}”赋值，因为它是类。",
  "2630": "无法为“{0}”赋值，因为它是函数。",
  "2631": "无法为“{0}”赋值，因为它是命名空间。",
  "2632": "无法为“{0}”赋值，因为它是导入。",
  "2633": "JSX 属性访问表达式不能包含 JSX 命名空间名称",
  "2634": "“{0}”索引签名不兼容。",
  "2635": "类型“{0}”没有类型参数列表适用的签名。",
  "2636": "类型“{0}”不能分配给类型“{1}”，如方差批注所示。",
  "2637": "仅对象、函数、构造函数、映射类型的类型别名支持方差注释。",
  "2638": "类型 \"{0}\" 可以表示基元值，该值不允许作为“in”运算符的右操作数。",
  "2639": "React 组件不能包含 JSX 命名空间名称",
  "2649": "无法扩充具有值导出的模块“{0}”，因为它解析为一个非模块的实体。",
  "2650": "非抽象类表达式缺少“{0}”的以下成员的实现: {1} 和 {2} 等。",
  "2651": "枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。",
  "2652": "合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。",
  "2653": "非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。",
  "2654": "非抽象类“{0}”缺少“{1}”的以下成员的实现: {2}。",
  "2655": "非抽象类“{0}”缺少“{1}”的以下成员的实现: {2} 和 {3} 等。",
  "2656": "非抽象类表达式缺少“{0}”的以下成员的实现: {1}。",
  "2657": "JSX 表达式必须具有一个父元素。",
  "2658": "类型“{0}”提供的内容与签名“{1}”不匹配。",
  "2659": "\"target\" 选项为 \"ES2015\" 或更高版本时，仅对象字面量表达式的成员中允许 \"super\"。",
  "2660": "仅可在派生类或对象字面量表达式的成员中引用 \"super\"。",
  "2661": "无法导出“{0}”。仅可从模块中导出本地声明。",
  "2662": "找不到名称“{0}”。你的意思是静态成员“{1}.{0}”?",
  "2663": "找不到名称“{0}”。你的意思是实例成员“this.{0}”?",
  "2664": "扩大中的模块名无效，找不到模块“{0}”。",
  "2665": "扩大中的模块名称无效。模块“{0}”解析到位于“{1}”处的非类型化模块，其无法扩大。",
  "2666": "模块扩大中不允许导出和导出分配。",
  "2667": "模块扩大中不允许导入。请考虑将它们移动到封闭的外部模块。",
  "2668": "\"export\" 修饰符不可用于环境模块和模块扩大，因为它们始终可见。",
  "2669": "全局范围的扩大仅可直接嵌套在外部模块中或环境模块声明中。",
  "2670": "全局范围的扩大应具有 \"declare\" 修饰符，除非它们显示在已有的环境上下文中。",
  "2671": "无法扩大模块“{0}”，因为它解析为非模块实体。",
  "2672": "不可将“{0}”构造函数类型分配给“{1}”构造函数类型。",
  "2673": "类“{0}”的构造函数是私有的，仅可在类声明中访问。",
  "2674": "类“{0}”的构造函数是受保护的，仅可在类声明中访问。",
  "2675": "无法扩展类“{0}”。类构造函数标记为私有。",
  "2676": "两个取值函数必须都是抽象的或都是非抽象的。",
  "2677": "类型谓词的类型不可赋给其参数的类型。",
  "2678": "类型“{0}”不可与类型“{1}”进行比较。",
  "2679": "使用 'new' 关键字调用的函数的 'this' 类型不能为 'void'。",
  "2680": "“{0}”参数必须是第一个参数。",
  "2681": "构造函数不可具有 \"this\" 参数。",
  "2683": "\"this\" 隐式具有类型 \"any\"，因为它没有类型注释。",
  "2684": "类型为“{0}”的 \"this\" 上下文不能分配给类型为“{1}”的方法的 \"this\"。",
  "2685": "每个签名的 \"this\" 类型不兼容。",
  "2686": "“{0}”指 UMD 全局，但当前文件是模块。请考虑改为添加导入。",
  "2687": "“{0}”的所有声明必须具有相同的修饰符。",
  "2688": "找不到“{0}”的类型定义文件。",
  "2689": "无法扩展接口“{0}”。您是否想使用 \"implements\"?",
  "2690": "“{0}”仅引用一个类型，但在此处用作一个值。你是否想要使用“{0} 中的 {1}”?",
  "2692": "“{0}”是基元，但“{1}”是包装器对象。如可能首选使用“{0}”。",
  "2693": "“{0}”仅表示类型，但在此处却作为值使用。",
  "2694": "命名空间“{0}”没有已导出的成员“{1}”。",
  "2695": "逗号运算符的左侧未使用，没有任何副作用。",
  "2696": "\"Object\" 类型可分配给极少数其他类型。是否想要改用“任意”类型?",
  "2697": "异步函数或方法必须返回 “Promise”。请确保具有对 “Promise” 的声明或在 “--lib” 选项中包含了 “ES2015”。",
  "2698": "spread 类型只能从对象类型创建。",
  "2699": "静态属性“{0}”与构造函数“{1}”的内置属性函数“{0}”冲突。",
  "2700": "rest 类型只能从对象类型创建。",
  "2701": "对象 rest 分配的目标必须是变量或属性访问。",
  "2702": "“{0}”仅指类型，但在此用作命名空间。",
  "2703": "\"delete\" 运算符的操作数必须是属性引用。",
  "2704": "\"delete\" 运算符的操作数不能是只读属性。",
  "2705": "ES5 中的异步函数或方法需要“Promise”构造函数。请确保对 “Promise” 构造函数进行了声明或在 “--lib” 选项中包含了 “ES2015”。",
  "2706": "所需的类型参数可能不遵循可选类型参数。",
  "2707": "泛型类型“{0}”需要介于 {1} 和 {2} 类型参数之间。",
  "2708": "不能将命名空间“{0}”用作值。",
  "2709": "不能将命名空间“{0}”用作类型。",
  "2710": "“{0}”被指定了两次。将覆盖名为“{0}”的特性。",
  "2711": "动态导入调用返回 “Promise”。请确保具有对 “Promise” 的声明或在 “--lib” 选项中包含了 “ES2015”。",
  "2712": "ES5 中的动态导入调用需要“Promise”构造函数。请确保对 “Promise” 构造函数进行了声明或在 “--lib” 选项中包含了 “ES2015”。",
  "2713": "无法访问“{0}.{1}”，因为“{0}”是类型，不是命名空间。是否要使用“{0}[\"{1}\"]”检索“{0}”中“{1}”属性的类型?",
  "2714": "导出分配的表达式必须是环境上下文中的标识符或限定的名称。",
  "2715": "不能在构造函数中访问类“{1}”中的抽象属性“{0}”。",
  "2716": "类型参数“{0}”具有循环默认值。",
  "2717": "后续属性声明必须属于同一类型。属性“{0}”的类型必须为“{1}”，但此处却为类型“{2}”。",
  "2718": "重复的属性 \"{0}\"。",
  "2719": "类型“{0}”无法分配给类型“{1}”。存在具有此名称的两种不同类型，但它们是不相关的。",
  "2720": "类“{0}”错误实现类“{1}”。你是想扩展“{1}”并将其成员作为子类继承吗?",
  "2721": "不能调用可能是 \"null\" 的对象。",
  "2722": "不能调用可能是“未定义”的对象。",
  "2723": "不能调用可能是 \"null\" 或“未定义”的对象。",
  "2724": "“{0}”没有导出的成员“{1}”。你是否指的是“{2}”?",
  "2725": "使用模块 {0} 将目标设置为 ES5 及更高版本时，类名不能为 \"Object\"。",
  "2726": "找不到“{0}”的库定义。",
  "2727": "找不到“{0}”的库定义。你是指“{1}”?",
  "2728": "在此处声明了 \"{0}\"。",
  "2729": "属性 \"{0}\" 在其初始化前已被使用。",
  "2730": "箭头函数不能包含 \"this\" 参数。",
  "2731": "\"symbol\" 到 \"string\" 的隐式转换将在运行时失败。请考虑在 \"String(...)\" 中包装此表达式。",
  "2732": "找不到模块“{0}”。请考虑使用 \"--resolveJsonModule\" 导入带 \".json\" 扩展的模块。",
  "2733": "属性 \"{0}\" 也在此处声明。",
  "2734": "是否缺少分号?",
  "2735": "你是想将 \"{0}\" 限制为类型 \"new (...args: any[]) => {1}\" 吗?",
  "2736": "运算符 \"{0}\" 不能应用于类型 \"{1}\"。",
  "2737": "目标低于 ES2020 时，BigInt 字面量不可用。",
  "2738": "此容器隐藏了 \"this\" 的外部值。",
  "2739": "类型“{0}”缺少类型“{1}”中的以下属性: {2}",
  "2740": "类型“{0}”缺少类型“{1}”的以下属性: {2} 及其他 {3} 项。",
  "2741": "类型 \"{1}\" 中缺少属性 \"{0}\"，但类型 \"{2}\" 中需要该属性。",
  "2742": "如果没有引用 \"{1}\"，则无法命名 \"{0}\" 的推断类型。这很可能不可移植。需要类型注释。",
  "2743": "没有需要 {0} 类型参数的重载，但存在需要 {1} 或 {2} 类型参数的重载。",
  "2744": "类型参数默认值只能引用以前声明的类型参数。",
  "2745": "此 JSX 标记的 \"{0}\" 属性需要类型 \"{1}\"，该类型需要多个子级，但仅提供了一个子级。",
  "2746": "此 JSX 标记的 \"{0}\" 属性需要 \"{1}\" 类型的子级，但提供了多个子级。",
  "2747": "\"{0}\" 组件不接受文本作为子元素。JSX 中的文本类型为 \"string\"，但 \"{1}\" 的预期类型为 \"{2}\"。",
  "2748": "启用“{0}”时，无法访问环境常量枚举。",
  "2749": "“{0}”表示值，但在此处用作类型。是否指“类型 {0}”?",
  "2750": "在此处声明实现签名。",
  "2751": "循环源自此位置的类型。",
  "2752": "在此处显示第一个导出默认值。",
  "2753": "这里是其他导出默认值。",
  "2754": "\"super\" 不能使用类型参数。",
  "2755": "不可调用 \"{0}\" 类型的任何组成部分。",
  "2756": "\"{0}\" 类型的部分要素不可调用。",
  "2757": "类型 \"{0}\" 没有调用签名。",
  "2758": "联合类型 \"{0}\" 的每个成员都有签名，但这些签名都不能互相兼容。",
  "2759": "不可构造 \"{0}\" 类型的任何组成部分。",
  "2760": "\"{0}\" 类型的部分要素不可构造。",
  "2761": "类型 \"{0}\" 没有构造签名。",
  "2762": "联合类型 \"{0}\" 的每个成员都有构造签名，但这些签名都不能互相兼容。",
  "2763": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但 for-of 将始终发送 \"{0}\"。",
  "2764": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但数组扩张将始终发送 \"{0}\"。",
  "2765": "无法迭代值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但数组析构将始终发送 \"{0}\"。",
  "2766": "无法将迭代委托到值，因为其迭代器的 \"next\" 方法需要类型 \"{1}\"，但包含它的生成器将始终发送 \"{0}\"。",
  "2767": "迭代器的 \"{0}\" 属性必须是方法。",
  "2768": "异步迭代器的 \"{0}\" 属性必须是方法。",
  "2769": "没有与此调用匹配的重载。",
  "2770": "最后一个重载给出了以下错误。",
  "2771": "在此处声明最后一个重载。",
  "2772": "第 {0} 个重载(共 {1} 个)，“{2}”，出现以下错误。",
  "2773": "是否忘记使用 \"await\"?",
  "2774": "此条件将始终返回 true，因为始终定义了函数。你是想改为调用它吗?",
  "2775": "断言要求使用显式类型注释声明调用目标中的每个名称。",
  "2776": "断言要求调用目标为标识符或限定名。",
  "2777": "增量或减量运算符的操作数不能是可选属性访问。",
  "2778": "对象 rest 分配的目标不能是可选属性访问。",
  "2779": "赋值表达式的左侧不能是可选属性访问。",
  "2780": "\"for…in\" 语句的左侧不能是可选属性访问。",
  "2781": "\"for…of\" 语句的左侧不能是可选属性访问。",
  "2782": "\"{0}\" 需要显式类型注释。",
  "2783": "多次指定了 \"{0}\"，因此将重写此用法。",
  "2784": "\"get\" 和 \"set\" 访问器无法声明 \"this\" 参数。",
  "2785": "此扩张将始终覆盖此属性。",
  "2786": "“{0}”不能用作 JSX 组件。",
  "2787": "其返回类型 \"{0}\" 不是有效的 JSX 元素。",
  "2788": "其实例类型 \"{0}\" 不是有效的 JSX 元素。",
  "2789": "其元素类型 \"{0}\" 不是有效的 JSX 元素。",
  "2790": "\"delete\" 运算符的操作数必须是可选的。",
  "2791": "除非 \"target\" 选项设置为 \"es2016\" 或更高版本，否则不能对 \"bigint\" 值执行求幂运算。",
  "2792": "找不到模块“{0}”。你的意思是要将 \"moduleResolution\" 选项设置为 \"nodenext\"，还是要将别名添加到 \"paths\" 选项中?",
  "2793": "针对此实现的调用已成功，但重载的实现签名在外部不可见。",
  "2794": "应为 {0} 个参数，但得到的却是 {1} 个。你是否忘了将类型参数中的 \"void\" 包含到 \"Promise\"?",
  "2795": "\"intrinsic\" 关键字只能用于声明编译器提供的内部类型。",
  "2796": "很可能缺少了分隔这两个模板表达式的逗号。它们构成了无法调用的带标记的模板表达式。",
  "2797": "从包含抽象构造签名的类型变量扩展的 mixin 类也必须声明为 \"abstract\"。",
  "2798": "该声明曾在此处标记为已弃用。",
  "2799": "类型生成的元组类型太大，无法表示。",
  "2800": "表达式生成的元组类型太大，无法表示。",
  "2801": "此条件将始终返回 true，因为此“{0}”已始终定义。",
  "2802": "只有在使用 \"--downlevelIteration\" 标志或 \"--target\" 为 \"es2015\" 或更高版本时，才能循环访问类型“{0}”。",
  "2803": "无法赋值给私有方法“{0}”。私有方法不可写。",
  "2804": "标识符 \"{0}\" 重复。静态元素和实例元素不能共享相同的专用名称。",
  "2806": "定义了专用访问器，但没有 Getter。",
  "2807": "此语法需要一个名为 \"{1}\" 且包含 {2} 参数的导入帮助程序，该帮助程序与 \"{0}\" 中的相应帮助程序不兼容。请考虑升级 \"{0}\" 的版本。",
  "2808": "Get 访问器必须至少具有与 Setter 相同的可访问性",
  "2809": "应为声明或语句。此 \"=\" 遵循语句块，因此如果打算编写重构赋值，则可能需要用括号将整个赋值括起来。",
  "2810": "应为 1 个参数，但得到 0。“new Promise()” 需要 JSDoc 提示才能生成可在没有参数的情况下调用的 “resolve”。",
  "2811": "属性“{0}”的初始化表达式",
  "2812": "属性“{0}”在类型 “{1}” 上不存在。请尝试将 “lib” 编译器选项更改为包含 “dom”。",
  "2813": "类声明无法实现“{0}”的重载列表。",
  "2814": "具有正文的函数只能与环境类合并。",
  "2815": "无法在属性初始值设定项或类静态初始化块中引用 'arguments'。",
  "2816": "无法在修饰类静态属性初始化表达式中使用 “this”。",
  "2817": "属性“{0}”没有初始化表达式，并且未在类静态块中明确分配。",
  "2818": "标识符“{0}”重复。在静态初始化表达式中中发出 “super” 引用时，编译器保留名称“{1}”。",
  "2819": "命名空间名称不能为“{0}”。",
  "2820": "类型“{0}”不可分配给类型“{1}”。你的意思是“{2}”?",
  "2821": "仅当 ‘--module’ 选项设置为 ‘esnext’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’ 时，才支持导入断言。",
  "2822": "导入断言不能用于仅类型导入或导出。",
  "2823": "仅当 ‘--module’ 选项设置为 ‘esnext’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’ 时，才支持导入属性。",
  "2833": "找不到命名空间“{0}”。你是否指的是“{1}”?",
  "2834": "当 \"--moduleResolution\" 为 \"node16\" 或 \"nodenext\" 时，相对导入路径需要 ECMAScript 导入中的显式文件扩展名。请考虑将扩展名添加到导入路径中。",
  "2835": "当“--moduleResolution”为“node16” 或“nodenext”时，相对导入路径需要 ECMAScript 导入中的显式文件扩展名。你是想使用 \"{0}\" 吗?",
  "2836": "不允许在编译到 commonJS“require”调用的语句导入断言。",
  "2837": "导入断言值必须为字符串字面量表达式。",
  "2838": "\"{0}\" 的所有声明必须具有相同的限制。",
  "2839": "此条件将始终返回“{0}”，因为 JavaScript 按引用而不是值比较对象。",
  "2840": "接口无法扩展“{0}”这样的基元类型。它只能扩展其他命名对象类型。",
  "2842": "“{0}”是“{1}”的未使用重命名。是否打算将其用作类型批注?",
  "2843": "我们只能通过在此处为整个参数添加类型来写入“{0}”的类型。",
  "2844": "实例成员变量“{0}”的类型不能引用构造函数中声明的标识符“{1}”。",
  "2845": "此条件将始终返回“{0}”。",
  "2846": "如果没有“导入类型”，则无法导入声明文件。是否要改为导入实现文件“{0}”?",
  "2848": "\"instanceof\" 表达式的右侧不能是实例化表达式。",
  "2849": "目标签名提供的自变量太少。预期为 {0} 个或更多，但实际为 {1} 个。",
  "2850": "\"using\" 声明的初始值设定项必须是具有 \"[Symbol.dispose]()\" 方法的对象，或为 \"null\" 或 \"undefined\"。",
  "2851": "\"await using\" 声明的初始值设定项必须是具有 \"[Symbol.asyncDispose]()\" 或 \"[Symbol.dispose]5D;()\" 方法的对象，或者是 \"null\" 或 \"undefined\"。",
  "2852": "\"await using\" 语句仅允许在异步函数和顶级模块中使用。",
  "2853": "只有当文件是模块时，才允许在该文件的顶层使用 \"await using\" 语句，但此文件没有导入或导出。可考虑添加空的 \"export {}\" 将此文件变为模块。",
  "2854": "仅当 ‘module’ 选项设置为 ‘es2022’、‘esnext’、‘system’、‘node16’、‘node18’、‘node20’、‘nodenext’ 或 ‘preserve’ 且 ‘target’ 选项设置为 ‘es2017’ 或更高时，才允许使用顶级 ‘await using’ 语句。",
  "2855": "父类定义的类字段“{0}”无法通过 super 在子类中访问。",
  "2856": "不允许在编译到 commonJS“require” 调用的语句导入属性。",
  "2857": "导入属性不能用于仅类型导入或导出。",
  "2858": "导入属性值必须为字符串字面量表达式。",
  "2859": "比较类型“{0}”和“{1}”的复杂性过高。",
  "2860": "\"instanceof\" 表达式的左侧必须可分配给右侧 \"[Symbol.hasInstance]\" 方法的第一个自变量。",
  "2861": "对象的“[Symbol.hasInstance]”方法必须返回布尔值，这样它才能在“instanceof”表达式的右侧使用。",
  "2862": "类型“{0}”是泛型的，只能编制索引以供读取。",
  "2863": "类无法扩展“{0}”这样的基元类型。类只能扩展可构造值。",
  "2864": "类无法实现类似于“{0}”的基元类型。它只能实现其他命名对象类型。",
  "2865": "导入“{0}”与本地值冲突，因此在启用“isolatedModules”时必须使用仅类型导入进行声明。",
  "2866": "导入“{0}”与此文件中使用的全局值冲突，因此在启用“isolatedModules”时必须使用仅类型导入进行声明。",
  "2867": "找不到名称“{0}”。你是否需要安装 Bun 的类型定义?请尝试运行 `npm i --save-dev @types/bun`。",
  "2868": "找不到名称“{0}”。你是否需要安装 Bun 的类型定义?请尝试运行 `npm i --save-dev @types/bun`，然后将 \"bun\" 添加到 tsconfig 的 types 字段。",
  "2869": "由于左操作数永远不会为空，因此 ?? 的右操作数无法访问。",
  "2870": "此二进制表达式永远不会为 null。是否缺少括号?",
  "2871": "此表达式始终为 null。",
  "2872": "这种表达式的结果始终为 true。",
  "2873": "这种表达式的结果始终为 false。",
  "2874": "此 JSX 标记要求 ‘{0}’ 在范围内，但找不到它。",
  "2875": "此 JSX 标记要求模块路径 ‘{0}’ 存在，但找不到任何路径。请确保已安装相应包的类型。",
  "2876": "重写此相对导入路径并不安全，因为它看起来像文件名，但实际上解析为 ‘{0}’。",
  "2877": "此导入使用 ‘{0}’ 扩展解析为输入 TypeScript 文件，但不会在发出期间重写，因为它不是相对路径。",
  "2878": "重写此导入路径并不安全，因为它会解析为另一个项目，并且项目的输出文件之间的相对路径与其输入文件之间的相对路径不同。",
  "2879": "使用 JSX 片段需要片段工厂 ‘{0}’ 在范围内，但找不到它。",
  "2880": "导入断言已被导入属性替换。使用 “with” 而不是 “assert”。",
  "2881": "此表达式从不为 null。",
  "4000": "导入声明“{0}”使用的是专用名称“{1}”。",
  "4002": "导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4004": "导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4006": "导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4008": "导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4010": "导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4012": "导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4014": "导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4016": "导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "4019": "导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。",
  "4020": "导出的类“{0}”的 \"extends\" 子句具有或正在使用专用名称“{1}”。",
  "4021": "导出的类的 \"extends\" 子句具有或正在使用专用名称“{0}”。",
  "4022": "导出接口“{0}”的 \"extends\" 子句具有或正在使用专用名称“{1}”。",
  "4023": "导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4024": "导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4025": "导出的变量“{0}”具有或正在使用专用名称“{1}”。",
  "4026": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4027": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。",
  "4028": "导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。",
  "4029": "导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4030": "导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4031": "导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。",
  "4032": "导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4033": "导出接口的属性“{0}”具有或正在使用专用名称“{1}”。",
  "4034": "导出类中的公共静态 setter“{0}”的参数类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4035": "导出类中的公共静态 setter“{0}”的参数类型具有或正在使用专用名称“{1}”。",
  "4036": "导出类中的公共 setter“{0}”的参数类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4037": "导出类中的公共 setter“{0}”的参数类型具有或正在使用专用名称“{1}”。",
  "4038": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4039": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4040": "导出类中的公共静态 getter“{0}”的返回类型具有或正在使用专用名称“{1}”。",
  "4041": "导出类中的公共 getter“{0}”的返回类型具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4042": "导出类中的公共 getter“{0}”的返回类型具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4043": "导出类中的公共 getter“{0}”的返回类型具有或正在使用专用名称“{1}”。",
  "4044": "导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4045": "导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。",
  "4046": "导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4047": "导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。",
  "4048": "导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4049": "导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。",
  "4050": "导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4051": "导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4052": "导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。",
  "4053": "导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4054": "导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4055": "导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。",
  "4056": "导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4057": "导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。",
  "4058": "导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "4059": "导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "4060": "导出函数的返回类型具有或正在使用专用名称“{0}”。",
  "4061": "导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4062": "导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4063": "导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4064": "导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4065": "导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4066": "导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4067": "导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4068": "导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4069": "导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4070": "导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4071": "导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4072": "导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4073": "导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4074": "导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4075": "导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4076": "导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。",
  "4077": "导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4078": "导出函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4081": "导出的类型别名“{0}”已经或正在使用专用名称“{1}”。",
  "4082": "模块的默认导出具有或正在使用专用名称“{0}”。",
  "4083": "已导出类型别名的类型参数“{0}”具有或正使用专用名称“{1}”。",
  "4084": "导出的类型别名“{0}”具有或正在使用模块“{2}”中的专用名称“{1}”。",
  "4085": "推断类型“{0}”的 Extends 子句具有或正在使用专用名称“{1}”。",
  "4091": "来自导出接口的索引签名的参数“{0}”具有或正在使用来自私有模块“{2}”的名称“{1}”。",
  "4092": "来自导出接口的索引签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "4094": "导出匿名类类型的属性“{0}”可能不是私有或受保护的属性。",
  "4095": "导出类的公共静态方法“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4096": "导出类的公共静态方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4097": "导出类的公共静态方法“{0}”具有或正在使用专用名称“{1}”。",
  "4098": "导出类的公共方法“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "4099": "导出类的公共方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4100": "导出类的公共方法“{0}”具有或正在使用专用名称“{1}”。",
  "4101": "导出接口的方法“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "4102": "导出接口的方法“{0}”具有或正在使用专用名称“{1}”。",
  "4103": "已导出映射对象类型的类型参数 \"{0}\" 使用专用名称 \"{1}\" 。",
  "4104": "类型 \"{0}\" 为 \"readonly\"，不能分配给可变类型 \"{1}\"。",
  "4105": "不能在类型参数上访问专用或受保护的成员 \"{0}\"。",
  "4106": "访问器的参数 \"{0}\" 具有或正在使用专用名称 \"{1}\"。",
  "4107": "访问器的参数 \"{0}\" 具有或正在使用专用模块 \"{2}\" 中的名称 \"{1}\" 。",
  "4108": "访问器的参数 \"{0}\" 具有或正在使用外部模块 \"{2}\" 中的名称 \"{1}\" ，但不能为其命名。",
  "4109": "\"{0}\" 的类型参数循环引用自身。",
  "4110": "元组类型参数循环引用自身。",
  "4111": "属性“{0}”来自索引签名，因此必须使用[“{0}”]访问它。",
  "4112": "此成员不能有 \"override\" 修饰符，因为它的包含类 \"{0}\" 不扩展其他类。",
  "4113": "此成员不能有 \"override\" 修饰符，因为它未在基类 \"{0}\" 中声明。",
  "4114": "此成员必须有 \"override\" 修饰符，因为它替代基类 \"{0}\" 中的一个成员。",
  "4115": "此参数属性必须具有 “override” 修饰符，因为它会替代基类“{0}”中的成员。",
  "4116": "此成员必须有 \"override\" 修饰符，因为它替代基类 \"{0}\" 中声明的一个抽象方法。",
  "4117": "此成员不能有 “override” 修饰符，因为它未在基类“{0}”中声明。你是否指的是“{1}”?",
  "4118": "无法序列化此节点的类型，因为无法序列化其属性“{0}”。",
  "4119": "此成员必须具有带 “@override” 标记的 JSDoc 注释，因为它会替代基类“{0}”中的成员。",
  "4120": "此参数属性必须具有带 “@override” 标记的 JSDoc 注释，因为它将替代基类“{0}”中的成员。",
  "4121": "此成员不能具有带 “@override” 标记的 JSDoc 注释，因为所包含的类“{0}”不会扩展其他类。",
  "4122": "此成员不能具有带 “@override” 标记的 JSDoc 注释，因为未在基类“{0}”中对其进行声明。",
  "4123": "此成员不能具有带 “override” 标记的 JSDoc 注释，因为未在基类“{0}”中对其进行声明。你是否指的是“{1}”?",
  "4124": "值“{1}”的编译器选项“{0}”不稳定。使用夜间 TypeScript 消除此错误。请尝试使用 “npm install -D typescript@next” 进行更新。",
  "4125": "“{0}.{1}”的每个声明的值不同，其中应为“{2}”，但给出的是“{3}”。",
  "4126": "“{0}.{1}”的一个值是字符串“{2}”，另一个值被假定为未知数值。",
  "4127": "此成员不能具有 “override” 修饰符，因为其名称是动态的。",
  "4128": "此成员不能拥有带有 ‘@overrid’ 标记的 JSDoc 注释，因为其名称是动态的。",
  "5001": "当前主机不支持“{0}”选项。",
  "5009": "找不到输入文件的公共子目录路径。",
  "5010": "文件规范不能以递归目录通配符结尾(\"**\"):“{0}”。",
  "5012": "无法读取文件“{0}”: {1}。",
  "5023": "未知的编译器选项“{0}”。",
  "5024": "编译器选项“{0}”需要类型 {1} 的值。",
  "5025": "未知的编译器选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5033": "无法写入文件“{0}”: {1}。",
  "5042": "选项 \"project\" 在命令行上不能与源文件混合使用。",
  "5047": "选项 \"isolatedModules\" 只可在提供了选项 \"--module\" 或者选项 \"target\" 是 \"ES2015\" 或更高版本时使用。",
  "5051": "仅当提供了选项 \"--inlineSourceMap\" 或选项 \"--sourceMap\" 时，才能使用选项“{0}”。",
  "5052": "无法在不指定选项“{1}”的情况下指定选项“{0}”。",
  "5053": "选项“{0}”不能与选项“{1}”同时指定。",
  "5054": "已在“{0}”中定义了 \"tsconfig.json\" 文件。",
  "5055": "无法写入文件“{0}”，因为它会覆盖输入文件。",
  "5056": "无法写入文件“{0}”，因为它会被多个输入文件覆盖。",
  "5057": "无法在指定目录找到 tsconfig.json 文件:“{0}”。",
  "5058": "指定的路径不存在:“{0}”。",
  "5059": "\"--reactNamespace\" 的值无效。“{0}”不是有效的标识符。",
  "5061": "模式“{0}”最多只可具有一个 \"*\" 字符。",
  "5062": "模式 \"{1}\" 中的替代项 \"{0}\" 最多只能有一个 \"*\" 字符",
  "5063": "模式“{0}”的替代应为数组。",
  "5064": "模式“{1}”的替换“{0}”类型不正确，应为 \"string\"，实际为“{2}”。",
  "5065": "文件规范不能包含出现在递归目录通配符(\"*\"): “{0}”后的父目录(\"..\")。",
  "5066": "模式“{0}”的替换模式不应为空数组。",
  "5067": "\"jsxFactory\" 的值无效。“{0}”不是有效的标识符或限定名称。",
  "5068": "添加 tsconfig.json 文件有助于组织包含 TypeScript 和 JavaScript 文件的项目。有关详细信息，请访问 https://aka.ms/tsconfig。",
  "5069": "无法在不指定选项 {1} 或选项 {2} 的情况下指定选项 {0}。",
  "5070": "当“moduleResolution”设置为“classic”时，无法指定选项“--resolveJsonModule”。",
  "5071": "当“module”设置为“none”、“system”或“umd”时，无法指定选项“--resolveJsonModule”。",
  "5072": "未知的生成选项 \"{0}\"。",
  "5073": "生成选项 \"{0}\" 需要类型 {1} 的值。",
  "5074": "选项 “--incremental” 只能使用 tsconfig 指定，在发出到单个文件时指定，或在指定了选项 “--tsBuildInfoFile” 时指定。",
  "5075": "\"{0}\" 可赋给 \"{1}\" 类型的约束，但可以使用约束 \"{2}\" 的其他子类型实例化 \"{1}\"。",
  "5076": "不能在不使用括号的情况下混用 \"{0}\" 和 \"{1}\" 操作。",
  "5077": "未知的生成选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5078": "未知观察选项 \"{0}\"。",
  "5079": "未知的监视选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "5080": "观察选项 \"{0}\" 需要 {1} 类型的值。",
  "5081": "无法在当前目录找到 tsconfig.json 文件: {0}。",
  "5082": "“{0}”可以使用与“{1}”无关的任意类型进行实例化。",
  "5083": "无法读取文件“{0}”。",
  "5085": "元组成员不能既是可选的又是 rest。",
  "5086": "标记的元组元素被声明为可选，并且问号位于名称之后、冒号之前，而不是位于类型之后。",
  "5087": "标记的元组元素通过在名称之前(而不是类型之前)的 “...” 声明为 rest。",
  "5088": "推断类型“{0}”引用的类型具有无法简单序列化的循环结构。必须具有类型注释。",
  "5089": "选项 \"jsx\" 为“{1}”时，不能指定选项“{0}”。",
  "5090": "未设置 \"baseUrl\" 时，不允许使用非相对路径。是否忘记了前导 \"./\"?",
  "5091": "启用“{0}”时，无法禁用选项“preserveConstEnums”。",
  "5092": "“{0}”文件的根值必须是一个对象。",
  "5093": "编译器选项“--{0}”只能与 “--build” 一起使用。",
  "5094": "编译器选项“--{0}”不能与 “--build” 一起使用。",
  "5095": "只有在“module”设置为“preserve”或“es2015”或更高版本时，才能使用选项“{0}”。",
  "5096": "只有在设置“noEmit”或“emitDeclarationOnly”时，才能使用选项“allowImportingTsExtensions”。",
  "5097": "启用“allowImportingTsExtensions”时，导入路径只能以“{0}”扩展名结尾。",
  "5098": "只有在“moduleResolution”设置为“node16”、“nodenext”或“bundler”时，才能使用选项“{0}”。",
  "5101": "选项“{0}”已弃用，并将停止在 TypeScript {1} 中运行。指定 compilerOption“ignoreDeprecations”:“{2}”以使此错误静音。",
  "5102": "选项“{0}”已删除。请从配置中删除它。",
  "5103": "“--ignoreDeprecations”的值无效。",
  "5104": "选项“{0}”是冗余选项，不能与选项“{1}”同时指定。",
  "5105": "当“module”设置为“UMD”、“AMD”或“System”时，不能使用选项“verbatimModuleSyntax”。",
  "5106": "请改用“{0}”。",
  "5107": "选项“{0}={1}”已弃用，并将停止在 TypeScript {2} 中运行。指定 compilerOption“ignoreDeprecations”:“{3}”以使此错误静音。",
  "5108": "选项“{0}={1}”已删除。请从配置中删除它。",
  "5109": "当选项“module”设置为“{1}”时，选项“moduleResolution”必须设置为“{0}”(或保留为未指定)。",
  "5110": "当选项“moduleResolution”设置为“{1}”时，选项“module”必须设置为“{0}”。",
  "6000": "为每个相应的 \".d.ts\" 文件生成源映射。",
  "6001": "连接输出并将其发出到单个文件。",
  "6002": "生成相应的 \".d.ts\" 文件。",
  "6004": "指定调试调试程序应将 TypeScript 文件放置到的位置而不是源位置。",
  "6005": "监视输入文件。",
  "6006": "将输出结构重定向到目录。",
  "6007": "请勿清除生成代码中的常数枚举声明。",
  "6008": "如果报告了任何错误，请不要发出输出。",
  "6009": "请勿将注释发出到输出。",
  "6010": "请勿发出输出。",
  "6011": "允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。",
  "6012": "跳过声明文件的类型检查。",
  "6013": "不要解析 symlink 的真实路径。",
  "6014": "仅发出 \".d.ts\" 声明文件。 ",
  "6015": "指定 ECMAScript 目标版本。",
  "6016": "指定模块代码生成。",
  "6017": "打印此消息。",
  "6019": "打印编译器的版本。",
  "6020": "编译给定了其配置文件路径或带 \"tsconfig.json\" 的文件夹路径的项目。",
  "6023": "语法: {0}",
  "6024": "选项",
  "6025": "文件",
  "6026": "示例: {0}",
  "6027": "选项:",
  "6029": "版本 {0}",
  "6030": "从文件插入命令行选项和文件。",
  "6031": "在监视模式下开始编译...",
  "6032": "检测到文件更改。正在启动增量编译...",
  "6034": "种类",
  "6035": "文件",
  "6036": "版本",
  "6037": "位置",
  "6038": "目录",
  "6039": "策略",
  "6040": "文件或目录",
  "6041": "错误文件",
  "6043": "生成相应的 \".map\" 文件。",
  "6044": "编译器选项“{0}”需要参数。",
  "6045": "响应文件“{0}”中引号不配对。",
  "6046": "“{0}”选项的参数必须为 {1}。",
  "6048": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
  "6050": "无法打开文件“{0}”。",
  "6051": "区域设置文件 {0} 已损坏。",
  "6052": "对具有隐式 \"any\" 类型的表达式和声明引发错误。",
  "6053": "找不到文件“{0}”。",
  "6054": "文件“{0}”具有不受支持的扩展名。仅支持 {1} 扩展名。",
  "6055": "抑制缺少索引签名的索引对象的 noImplicitAny 错误。",
  "6056": "请勿对具有 \"@internal\" 注释的代码发出声明。",
  "6058": "指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。",
  "6059": "文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。",
  "6060": "指定发出文件时要使用的行序列结尾: \"CRLF\" (dos)或 \"LF\" (unix)。",
  "6061": "换行符",
  "6064": "选项“{0}”只能在 \"tsconfig.json\" 文件中指定或在命令行上设置为 \"null\"。",
  "6065": "对 ES7 修饰器启用实验支持。",
  "6066": "对发出修饰器的类型元数据启用实验支持。",
  "6070": "初始化 TypeScript 项目并创建 tsconfig.json 文件。",
  "6071": "已成功创建 tsconfig.json 文件。",
  "6072": "取消对对象字面量的多余属性检查。",
  "6073": "使用颜色和上下文风格化错误和消息(实验)。",
  "6074": "不报告有关未使用的标签的错误。",
  "6075": "在函数中的所有代码路径并非都返回值时报告错误。",
  "6076": "报告 switch 语句中遇到 fallthrough 情况的错误。",
  "6077": "不报告有关不可访问的代码的错误。",
  "6078": "不允许对同一文件采用大小不一致的引用。",
  "6079": "指定要在编译中包括的库文件。",
  "6080": "指定 JSX 代码生成。",
  "6082": "--{0} 旁仅支持 \"amd\" 和 \"system\" 模块。",
  "6083": "用于解析非绝对模块名的基目录。",
  "6084": "[已弃用] 请改用 \"--jsxFactory\"。已 \"react\" JSX 发出设为目标时，请指定要为 createElement 调用的对象",
  "6085": "启用名称解析过程的跟踪。",
  "6086": "======== 正在从“{1}”解析模块“{0}”。========",
  "6087": "显示指定了模块解析类型:“{0}”。",
  "6088": "未指定模块解析类型，正在使用“{0}”。",
  "6089": "======== 模块名“{0}”已成功解析为“{1}”。========",
  "6090": "======== 未解析模块名“{0}”。========",
  "6091": "指定了 \"paths“ 选项，正在查找模式以匹配模块名“{0}”。",
  "6092": "模块名“{0}”，匹配的模式“{1}”。",
  "6093": "正在尝试替换“{0}”，候选模块位置:“{1}”。",
  "6094": "正在相对于基 URL“{1}”-“{2}”解析模块名“{0}”。",
  "6095": "正在将模块作为文件/文件夹进行加载，候选模块位置“{0}”，目标文件类型: {1}。",
  "6096": "文件“{0}”不存在。",
  "6097": "文件“{0}”存在 - 将其用作名称解析结果。",
  "6098": "正在从 \"node_modules\" 文件夹加载模块“{0}”，目标文件类型: {1}。",
  "6099": "在“{0}”处找到了 \"package.json\"。",
  "6100": "\"package.json\" 没有“{0}”字段。",
  "6101": "\"package.json\" 具有引用“{2}”的“{0}”字段“{1}”。",
  "6102": "允许编译 JavaScript 文件。",
  "6104": "检查“{0}”是否是“{1}”-“{2}”的最长匹配前缀。",
  "6105": "\"package.json\" 中 \"{0}\" 字段的类型应为 \"{1}\"，但实际为 \"{2}\" 。",
  "6106": "\"baseUrl\" 选项设置为“{0}”，可使用此值解析非相关模块名称“{1}”。",
  "6107": "设置了 \"rootDirs\" 选项，可将其用于解析相对模块名称“{0}”。",
  "6108": "“{0}”的最长匹配前缀为“{1}”。",
  "6109": "正在从根目录“{1}”加载“{0}”，候选位置“{2}”。",
  "6110": "正在尝试 \"rootDirs\" 中的其他条目。",
  "6111": "使用 \"rootDirs\" 的模块解析失败。",
  "6112": "不要在模块输出中发出 \"use strict\" 指令。",
  "6113": "启用严格的 NULL 检查。",
  "6114": "未知的 \"excludes\" 选项。你的意思是 \"exclude\"?",
  "6115": "在带隐式“any\" 类型的 \"this\" 表达式上引发错误。",
  "6116": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，根目录“{2}”。========",
  "6119": "======== 类型引用指令“{0}”已成功解析为“{1}”，主要: {2}。========",
  "6120": "======== 未解析类型引用指令“{0}”。========",
  "6121": "正在使用主搜索路径“{0}”解析。",
  "6122": "无法确定根目录，正在跳过主搜索路径。",
  "6123": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，未设置根目录。========",
  "6124": "要包含在编译中类型声明文件。",
  "6125": "正在 \"node_modules\" 文件夹中查找，初始位置为“{0}”。",
  "6126": "未指定包含文件，并且无法确定根目录，正在跳过在 \"node_modules\" 文件夹中查找。",
  "6127": "======== 正在解析类型引用指令“{0}”，未设置包含文件，根目录“{1}”。========",
  "6128": "======== 正在解析类型引用指令“{0}”，未设置包含文件，未设置根目录。========",
  "6130": "正在解析“{0}”的真实路径，结果为“{1}”。",
  "6131": "无法使用选项“{0}”来编译模块，除非 \"--module\" 标记为 \"amd\" 或 \"system\"。",
  "6132": "文件名“{0}”的扩展名为“{1}”，请去除它。",
  "6133": "已声明“{0}”，但从未读取其值。",
  "6134": "报告未使用的局部变量上的错误。",
  "6135": "报告未使用的参数上的错误。",
  "6136": "用于搜索 node_modules 和加载 JavaScript 文件的最大依赖项深度。",
  "6137": "无法导入类型声明文件。请考虑导入“{0}”，而不是“{1}”。",
  "6138": "已声明属性“{0}”，但从未读取其值。",
  "6139": "从 \"tslib\" 导入发出帮助程序。",
  "6140": "项目“{0}”中启用了键入内容的自动发现。使用缓存位置“{2}”运行模块“{1}”的额外解决传递。",
  "6141": "以严格模式进行分析，并为每个源文件发出 \"use strict\" 指令。",
  "6142": "模块“{0}”已解析为“{1}”，但尚未设置 \"--jsx\"。",
  "6144": "模块“{0}”解析为文件“{1}”中本地声明的环境模块。",
  "6146": "指定在设定 \"react\" JSX 发出目标时要使用的 JSX 工厂函数，例如 \"react.createElement\" 或 \"h\"。",
  "6147": "在位置“{1}”的缓存中找到模块“{0}”的解析。",
  "6148": "目录“{0}”不存在，正在跳过该目录中的所有查找。",
  "6149": "显示诊断信息。",
  "6150": "显示详细的诊断信息。",
  "6151": "发出包含源映射而非包含单独文件的单个文件。",
  "6152": "在单个文件内发出源以及源映射；需要设置 \"--inlineSourceMap\" 或 \"--sourceMap\"。",
  "6153": "将每个文件转换为单独的模块(类似 \"ts.transpileModule\")。",
  "6154": "属于编译一部分的已生成文件的打印名称。",
  "6155": "属于编译一部分的文件的打印名称。",
  "6156": "向用户显示消息时所用的区域设置(例如，\"en-us\")",
  "6157": "请勿在已编译输出中生成自定义帮助程序函数，例如 \"__extends\"。",
  "6158": "请勿包括默认库文件(lib.d.ts)。",
  "6159": "请勿将三斜杠引用或导入的模块添加到已编译文件列表中。",
  "6160": "[已弃用] 请改用 \"--skipLibCheck\"。请跳过默认库声明文件的类型检查。",
  "6161": "包含类型定义来源的文件夹列表。",
  "6162": "禁用对 JavaScript 项目的大小限制。",
  "6163": "输入文件的字符集。",
  "6164": "正在跳过看起来像绝对 URI、目标文件类型的模块“{0}”: {1}。",
  "6165": "请勿删除错误消息。",
  "6166": "已生成声明文件的输出目录。",
  "6167": "一系列条目，这些条目将重新映射导入内容，以查找与 \"baseUrl\" 有关的位置。",
  "6168": "根文件夹列表，其组合内容表示在运行时的项目结构。",
  "6169": "显示所有编译器选项。",
  "6170": "[已弃用] 请改用 \"--outFile\"。连接并发出到单个文件的输出",
  "6171": "命令行选项",
  "6179": "以“ES5”设为目标时，对“for-of”、传播和析构中的可迭代项提供完全支持。",
  "6180": "启用所有严格类型检查选项。",
  "6182": "检测到范围包，请在“{0}”中查看",
  "6183": "正在重用旧程序“{1}”中模块“{0}”的解析，已成功将其解析为“{2}”。",
  "6184": "正在重用旧程序“{1}”中模块“{0}”的解析，已成功将其解析为包 ID 为“{3}”的“{2}”。",
  "6186": "对函数类型启用严格检查。",
  "6187": "启用类中属性初始化的严格检查。",
  "6188": "此处不允许使用数字分隔符。",
  "6189": "不允许使用多个连续的数字分隔符。",
  "6191": "是否在监视模式下保留过时的控制台输出，而不是清除屏幕。",
  "6192": "导入声明中的所有导入都未使用。",
  "6193": "找到 1 个错误。注意文件更改。",
  "6194": "找到 {0} 个错误。注意文件更改。",
  "6195": "只将 \"keyof\" 解析为字符串值的属性名称(不含数字或符号)。",
  "6196": "“{0}”已声明，但从未使用过。",
  "6197": "包括通过 \".json\" 扩展导入的模块",
  "6198": "所有解构出的成员都未使用。",
  "6199": "所有变量均未使用。",
  "6200": "以下标识符的定义与另一个文件中的定义冲突: {0}",
  "6201": "此文件中存在冲突。",
  "6202": "项目引用不能形成环形图。检测到循环: {0}",
  "6203": "此处也声明了 \"{0}\"。",
  "6204": "并在这里。",
  "6205": "未使用任何类型参数。",
  "6206": "\"package. json\" 具有 \"typesVersions\" 字段，它具有特定于版本的路径映射。",
  "6207": "\"package. json\" 没有与版本 \"{0}\" 匹配的 \"typesVersions\" 项。",
  "6208": "\"package. json\" 具有与编译器版本 \"{1}\" 匹配的 \"typesVersions\" 项 \"{0}\"，它需要与模块名称 \"{2}\" 匹配的模式。",
  "6209": "\"package. json\" 具有 \"typesVersions\" 项 \"{0}\"，它不是有效的 semver 范围。",
  "6210": "未提供 \"{0}\" 的自变量。",
  "6211": "未提供与此绑定模式匹配的自变量。",
  "6212": "你是想调用此表达式吗?",
  "6213": "你是想将 \"new\" 用于此表达式吗?",
  "6214": "对函数启用严格的 \"bind\"、\"call\" 和 \"apply\" 方法。",
  "6215": "使用项目引用重定向“{0}”的编译器选项。",
  "6216": "找到 1 个错误。",
  "6217": "找到 {0} 个错误。",
  "6218": "======== 模块名 \"{0}\" 已成功解析为 \"{1}\"，包 ID 为 \"{2}\"。========",
  "6219": "======== 类型引用指令 \"{0}\" 已成功解析为 \"{1}\" ，包 ID 为 \"{2}\"，主要: {3}。========",
  "6220": "\"package. json\" 具有错误的 \"{0}\" 字段。",
  "6221": "禁止使用源文件而不是引用项目中的声明文件。",
  "6222": "使用 Define 而不是 Set 发出类字段。",
  "6223": "生成 CPU 配置文件。",
  "6224": "对此项目禁用解决方案搜索。",
  "6225": "指定监视文件的策略: \"FixedPollingInterval\" (默认)、\"PriorityPollingInterval\"、\"DynamicPriorityPolling\"、\"FixedChunkSizePolling\"、\"UseFsEvents\"、\"UseFsEventsOnParentDirectory\"。",
  "6226": "指定在不支持本机递归监视的平台上监视目录的策略: \"UseFsEvents\" (默认)、\"FixedPollingInterval\"、\"DynamicPriorityPolling\"、\"FixedChunkSizePolling\"。",
  "6227": "指定在使用文件系统事件创建轮询监视失败时创建轮询监视的策略: \"FixedInterval\" (默认)、\"PriorityInterval\"、\"DynamicPriority\"、\"FixedChunkSize\"。",
  "6229": "标记“{0}”至少需要“{1}”个参数，但 JSX 工厂“{2}”最多可提供“{3}”个。",
  "6230": "选项“{0}”只能在 \"tsconfig.json\" 文件中指定，或者在命令行上设置为 \"false\" 或 \"null\"。",
  "6231": "无法解析具有表达式的路径“{0}”: {1}。",
  "6232": "该声明扩充了另一文件中的声明。这无法被序列化。",
  "6233": "这是正在扩充的声明。请考虑将扩充声明移到同一个文件中。",
  "6234": "此表达式是 \"get\" 访问器，因此不可调用。你想在不使用 \"()\" 的情况下使用它吗?",
  "6235": "禁止加载引用的项目。",
  "6236": "未提供 rest 形参“{0}”的实参。",
  "6237": "生成事件跟踪和类型列表。",
  "6238": "指定要用于从 eg,react 中导入 “jsx” 和 “jsxs” 工厂函数的模块说明符",
  "6239": "根据前面缓存的查找，文件“{0}”存在。",
  "6240": "根据前面缓存的查找，文件“{0}”不存在。",
  "6241": "在位置“{1}”的缓存中找到类型引用指令“{0}”的解析。",
  "6242": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”。========",
  "6243": "将可选属性类型解释为已写，而不是添加 \"undefined\"。",
  "6244": "模块",
  "6245": "文件管理",
  "6246": "发出",
  "6247": "JavaScript 支持",
  "6248": "类型检查",
  "6249": "编辑器支持",
  "6250": "观看和生成模式",
  "6251": "编译器诊断",
  "6252": "互操作约束",
  "6253": "向后兼容性",
  "6254": "语言和环境",
  "6255": "项目",
  "6256": "输出格式设置",
  "6257": "完成度",
  "6258": "应在 config json 文件的 “compilerOptions” 对象中设置 “{0}”",
  "6259": "在 {0} 中找到 1 个错误",
  "6260": "在同一文件中找到 {0} 个错误，起始位置为: {1}",
  "6261": "在 {1} 个文件中找到 {0} 个错误。",
  "6262": "文件名“{0}”具有“{1}”扩展 - 改为查找“{2}”。",
  "6263": "模块“{0}”已解析为“{1}”，但未设置“--allowArbitraryExtensions”。",
  "6264": "启用导入具有任何扩展名的文件，前提是存在声明文件。",
  "6265": "正在解析指定自定义 typeRoots 的程序的类型引用指令，跳过在“node_modules”文件夹中查找。",
  "6266": "选项“{0}”只能在命令行上指定。",
  "6270": "目录 '{0}' 不包含 package.json 作用域。导入将无法解析。",
  "6271": "路径 '{1}' 处的 package.json 作用域中不存在导入说明符 '{0}'。",
  "6272": "无效的导入说明符 '{0}' 没有可行的解决方法。",
  "6273": "package.json 作用域 '{0}' 未定义导入。",
  "6274": "package.json 作用域 '{0}' 将说明符 '{1}' 显式映射到 NULL。",
  "6275": "package.json 作用域 '{0}' 的说明符 '{1}' 的目标类型无效",
  "6276": "路径 '{1}' 处的 package.json 作用域中不存在导出说明符 '{0}'。",
  "6277": "解析非相对名称失败；正在尝试禁用新式节点解析功能，以查看 npm 库是否需要配置更新。",
  "6278": "“{0}”处有类型，但在遵守 package.json \"exports\" 时无法解析此结果。“{1}”库可能需要更新其 package.json 或键入。",
  "6279": "解析非相对名称失败；正在尝试“--moduleResolution 捆绑程序”，以查看项目是否可能需要配置更新。",
  "6280": "“{0}”处有类型，但无法在当前 \"moduleResolution\" 设置下解析此结果。请考虑更新到 \"node16\"、\"nodenext\" 或 \"bundler\"。",
  "6281": "\"package.json\" 具有 \"peerDependencies\" 字段。",
  "6282": "找到具有“{1}”版本的 peerDependency“{0}”。",
  "6283": "找不到 peerDependency“{0}”。",
  "6284": "文件布局",
  "6285": "环境设置",
  "6286": "另请参阅 https://aka.ms/tsconfig/module",
  "6287": "对于 nodejs:",
  "6290": "和 npm 安装 -D @types/节点",
  "6291": "其他输出",
  "6292": "更严格的类型检查选项",
  "6293": "样式选项",
  "6294": "建议的选项",
  "6302": "启用项目编译",
  "6304": "复合项目可能不会禁用声明发出。",
  "6305": "未从源文件“{1}”生成输出文件“{0}”。",
  "6306": "引用的项目“{0}”必须拥有设置 \"composite\": true。",
  "6307": "文件 \"{0}\" 不在项目 \"{1}\" 的文件列表中。项目必须列出所有文件，或使用 \"include\" 模式。",
  "6310": "引用的项目“{0}”可能不会禁用发出。",
  "6350": "项目“{0}”已过期，因为输出“{1}”早于输入“{2}”",
  "6351": "项目“{0}”是最新的，因为最新的输入“{1}”早于输出“{2}”",
  "6352": "项目“{0}”已过期，因为输出文件“{1}”不存在",
  "6353": "项目“{0}”已过期，因为其依赖项“{1}”已过期",
  "6354": "项目“{0}”已是最新，拥有来自其依赖项的 .d.ts 文件",
  "6355": "此生成中的项目: {0}",
  "6356": "非 -dry 生成将删除以下文件: {0}",
  "6357": "非 -dry 生成将生成项目“{0}”",
  "6358": "正在生成项目“{0}”...",
  "6359": "正在更新项目“{0}”的输出时间戳...",
  "6361": "“{0}”项目已是最新",
  "6362": "正在跳过项目“{0}”的生成，因为其依赖项“{1}”有错误",
  "6363": "无法生成项目“{0}”，因为其依赖项“{1}”有错误",
  "6364": "生成一个或多个项目及其依赖项(如果已过期)",
  "6365": "删除所有项目的输出。",
  "6367": "显示将生成(如果指定有 '--clean'，则删除)什么",
  "6369": "选项 '--build' 必须是第一个命令行参数。",
  "6370": "选项“{0}”与“{1}”不能组合在一起。",
  "6371": "正在更新项目 \"{0}\" 未更改的输出时间戳…",
  "6374": "非 dry 生成将更新项目 '{0}' 的输出的时间戳",
  "6377": "无法写入文件 \"{0}\"，因为它将覆盖由引用的项目 \"{1}\" 生成的 \".tsbuildinfo\" 文件",
  "6379": "复合项目不能禁用增量编译。",
  "6380": "指定用于存储增量编译信息的文件",
  "6381": "项目 \"{0}\" 已过期，因为其输出是使用与当前版本 \"{2}\" 不同的版本 \"{1}\" 生成的",
  "6382": "即将跳过项目 \"{0}\" 的生成，因为未生成其依赖项 \"{1}\"",
  "6383": "无法生成项目 \"{0}\" ，因为未生成其依赖项 \"{1}\"",
  "6384": "在 \"--incremental\" 和 \"--watch\" 中有重新编译，假定文件中的更改只会影响直接依赖它的文件。",
  "6385": "“{0}”已弃用。",
  "6386": "\"--diagnostics\" 或 \"--extendedDiagnostics\" 的性能计时在此会话中不可用。未能找到 Web 性能 API 的本机实现。",
  "6387": "“{1}”的签名“{0}”已弃用。",
  "6388": "正在强制重新生成项目“{0}”",
  "6389": "正在重用旧程序“{1}”中模块“{0}”的解析，但其未解析。",
  "6390": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，已成功将其解析为“{2}”。",
  "6391": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，已成功将其解析为包 ID 为“{3}”的“{2}”。",
  "6392": "正在重用旧程序“{1}”中类型引用指令“{0}”的解析，但其未解析。",
  "6393": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，已成功将其解析为“{3}”。",
  "6394": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，已成功将其解析为包 ID 为“{4}”的“{3}”。",
  "6395": "正在重用从位置“{2}”缓存中找到的“{1}”中模块“{0}”的解析，但其未解析。",
  "6396": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，已成功将其解析为“{3}”。",
  "6397": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，已成功将其解析为包 ID 为“{4}”的“{3}”。",
  "6398": "正在重用从位置“{2}”缓存中找到的“{1}”中类型引用指令“{0}”的解析，但其未解析。",
  "6399": "项目“{0}”已过期，因为 buildinfo 文件“{1}”指示某些更改未发出",
  "6400": "项目“{0}”是最新的，但需要更新早于输入文件的输出文件的时间戳",
  "6401": "项目“{0}”已过期，因为读取文件“{1}”时出错",
  "6402": "正在 {0} 模式下解析，条件为 {1}。",
  "6403": "匹配的“{0}”条件“{1}”。",
  "6404": "将“{0}”子路径“{1}”与目标“{2}”一起使用",
  "6405": "看到了不匹配的条件“{0}”。",
  "6406": "由于 buildinfo 文件“{1}”指示 compilerOptions 中存在更改，因此项目“{0}”已过期",
  "6407": "允许导入包含 TypeScript 文件扩展名。需要设置“--moduleResolution bundler”以及“--noEmit”或“--emitDeclarationOnly”。",
  "6408": "解析包导入时，请使用 package.json \"exports\" 字段。",
  "6409": "解析导入时，请使用 package.json \"import\" 字段。",
  "6410": "解析导入时除特定于解析程序的默认值外要设置的条件。",
  "6411": "当 \"moduleResolution\" 为 \"node16\"、\"nodenext \"或 \"bundler\" 时为 `true`；否则为 `false`。",
  "6412": "由于 buildinfo 文件“{1}”指示文件“{2}”曾是编译的根文件，但不再是了，因此项目“{0}”已过期。",
  "6413": "正在输入条件导出。",
  "6414": "已在条件“{0}”下解析。",
  "6415": "无法在条件“{0}”下解析。",
  "6416": "正在退出条件导出。",
  "6417": "正在搜索所有上级 node_modules 目录以查找首选扩展: {0}。",
  "6418": "正在搜索所有上级 node_modules 目录以查找回退扩展: {0}。",
  "6419": "由于 buildinfo 文件“{1}”指示程序需要报告错误，因此项目“{0}”已过期。",
  "6420": "由于 {1}，项目“{0}”已过期。",
  "6421": "将相对导入路径中的 ‘.ts’、‘.tsx’、‘.mts’ 和 ‘.cts’ 文件扩展名改写为其在输出文件中的 JavaScript 等效项。",
  "6500": "所需类型来自属性 \"{0}\"，在此处的 \"{1}\" 类型上声明该属性",
  "6501": "所需类型来自此索引签名。",
  "6502": "所需类型来自此签名的返回类型。",
  "6503": "打印编译包含的文件的名称，然后停止处理。",
  "6504": "文件 \"{0}\" 是 JavaScript 文件。你是想启用 \"allowJs\" 选项吗?",
  "6505": "打印文件的名称及编译包含这些文件的原因。",
  "6506": "请考虑向此类添加 “declare” 修饰符。",
  "6600": "允许 JavaScript 文件成为程序的一部分。使用 ''checkJs'' 选项来获取这些文件中的错误。",
  "6601": "当模块没有默认导出时，允许“从 y 导入 x”。",
  "6602": "允许从模块访问 UMD 变量全局。",
  "6603": "对无法访问的代码禁用错误报告。",
  "6604": "对未使用的标签禁用错误报告。",
  "6605": "请确保始终发出 “se strict”。",
  "6606": "在使用 “incremental” 和 “watch” 模式的项目中具有重新编译会假定文件中的更改将仅直接影响依赖于它的文件。",
  "6607": "指定基目录以解析非相关模块名称。",
  "6608": "不再受支持。在早期版本中，手动设置用于读取文件的文本编码。",
  "6609": "在已检查类型的 JavaScript 文件中启用错误报告。",
  "6611": "启用允许将 TypeScript 项目与项目引用一起使用的约束。",
  "6612": "从项目的 TypeScript 和 JavaScript 文件生成 .d.ts 文件。",
  "6613": "指定已生成声明文件的输出目录。",
  "6614": "为 d.ts 文件创建源映射。",
  "6615": "生成后输出编译器性能信息。",
  "6616": "禁用通过查看项目中的文件名进行类型获取推理。",
  "6617": "减少 TypeScript 自动加载的项目数。",
  "6618": "删除 TypeScript 语言服务器中 JavaScript 文件总源代码大小 20mb 的上限。",
  "6619": "在编辑时选择项目退出多项目引用检查。",
  "6620": "在引用复合项目时禁用首选源文件而不是声明文件。",
  "6621": "发出更合规但更详细且性能较低的 JavaScript 进行迭代。",
  "6622": "在输出文件的开头发出一个 UTF-8 字节顺序标记(BOM)。",
  "6623": "仅输出 d.ts 文件，而不输出 JavaScript 文件。",
  "6624": "为源文件中的修饰声明发出设计类型元数据。",
  "6625": "禁用针对 JavaScript 项目的类型获取",
  "6626": "发出其他 JavaScript 以轻松支持导入 CommonJS 模块。这将启用 “allowSyntheticDefaultImports” 以实现类型兼容性。",
  "6627": "从 “include” 选项筛选结果。",
  "6628": "从监视进程中删除目录列表。",
  "6629": "从监视模式的处理中删除文件列表。",
  "6630": "启用对旧实验性修饰器的实验性支持。",
  "6631": "打印在编译过程中读取的文件，包括包含它的原因。",
  "6632": "生成后输出更详细的编译器性能信息。",
  "6633": "指定对从中继承设置的基本配置文件的一个或多个路径或节点模块引用。",
  "6634": "指定当系统耗尽本机文件观察程序时，观察程序应使用的方法。",
  "6635": "包含文件列表。这不支持 glob 模式，与 “include” 不同。",
  "6636": "生成所有项目，包括那些似乎是最新的项目。",
  "6637": "确保导入中的大小写正确。",
  "6638": "发出用于调试的编译器运行的 v8 CPU 配置文件。",
  "6639": "允许每个项目从 tslib 导入帮助程序函数一次，而不是将它们包含在每个文件中。",
  "6640": "跳过在上游项目出错时生成下游项目。",
  "6641": "指定与要包含在编译中的文件匹配的 glob 模式列表。",
  "6642": "保存 .tsbuildinfo 文件以允许项目增量编译。",
  "6643": "在发出的 JavaScript 中包括源映射文件。",
  "6644": "在发出的 JavaScript 内的源映射中包含源代码。",
  "6645": "确保可以安全地转译每个文件，而无需依赖其他导入。",
  "6646": "指定生成的 JSX 代码。",
  "6647": "指定在将 React JSX 发出设定为目标时要使用的 JSX 中心函数，例如 “react.createElement” 或 “h”。",
  "6648": "指定在将 React JSX 发出设定为目标时用于片段的 JSX 片段引用，例如 “React.Fragment” 或 “Fragment”。",
  "6649": "指定使用 “jsx: react-jsx*” 时用于导入 JSX 中心函数的模块说明符。",
  "6650": "使 keyof 仅返回字符串，而不是字符串、数字或符号。旧版选项。",
  "6651": "指定一组描述目标运行时环境的捆绑库声明文件。",
  "6652": "编译后打印已发出文件的名称。",
  "6653": "打印在编译过程中读取的所有文件。",
  "6654": "设置来自 TypeScript 的消息传递的语言。这不会影响发出。",
  "6655": "指定调试程序应将映射文件放置到的位置而不是生成的位置。",
  "6656": "指定用于从 “node_modules” 检查 JavaScript 文件的最大文件夹深度。仅适用于 “allowJs”。",
  "6657": "指定生成的模块代码。",
  "6658": "指定 TypeScript 如何从给定的模块说明符查找文件。",
  "6659": "设置发出文件的换行符。",
  "6660": "禁用从编译发出文件。",
  "6661": "在已编译输出中禁用生成自定义帮助程序函数(如 “__extends”)。",
  "6662": "禁用在报告了任何类型检查错误时发出文件。",
  "6663": "在错误消息中禁用截断类型。",
  "6664": "为 switch 语句中的故障案例启用错误报告。",
  "6665": "对具有隐式 “any” 类型的表达式和声明启用错误报告。",
  "6666": "确保使用替代修饰符标记派生类中的替代成员。",
  "6667": "为未在函数中显式返回的代码路径启用错误报告。",
  "6668": "在 “this” 的类型为 “any” 时启用错误报告。",
  "6669": "禁止在发出的 JavaScript 文件中添加 “use strict” 指令。",
  "6670": "禁用包括任何库文件(包括默认的 lib.d.ts)。",
  "6671": "对使用索引类型声明的键强制使用索引访问器。",
  "6672": "禁止 “import”、“require” 或 “<reference>” 扩展 TypeScript 应添加到项目的文件数。",
  "6673": "禁止严格检查函数类型中的通用签名。",
  "6674": "使用索引访问时，将 “undefined” 添加到类型。",
  "6675": "在未读取局部变量时启用错误报告。",
  "6676": "在未读取函数参数时引发错误。",
  "6677": "弃用的设置。请改用 “outFile”。",
  "6678": "为所有已发出的文件指定输出文件夹。",
  "6679": "指定将所有输出捆绑到一个 JavaScript 文件中的文件。如果 “declaration” 为 true，还要指定一个捆绑所有 .d.ts 输出的文件。",
  "6680": "指定一组将导入重新映射到其他查找位置的条目。",
  "6681": "指定要包括的语言服务插件列表。",
  "6682": "在生成的代码中禁用擦除 “const enum” 声明。",
  "6683": "禁用将符号链接解析为其实际路径。这会关联到节点中的同一标志。",
  "6684": "禁用在监视模式下擦除控制台。",
  "6685": "在 TypeScript 输出中启用颜色和格式设置，以使编译器错误更易于阅读。",
  "6686": "指定为 “createElement” 调用的对象。这仅适用于将 “react” JSX 发出设定为目标的情况。",
  "6687": "指定为项目指定路径的对象数组。在项目引用中使用。",
  "6688": "禁用发出注释。",
  "6689": "启用导入 .json 文件。",
  "6690": "指定源文件中的根文件夹。",
  "6691": "允许在解析模块时将多个文件夹视为一个文件夹。",
  "6692": "跳过 TypeScript 附带的类型检查 .d.ts 文件。",
  "6693": "跳过对所有 .d.ts 文件的类型检查。",
  "6694": "为发出的 JavaScript 文件创建源映射文件。",
  "6695": "指定调试程序的根路径以查找引用源代码。",
  "6697": "检查 “bind”、“call” 和 “apply” 方法的参数是否与原始函数匹配。",
  "6698": "分配函数时，请检查以确保参数和返回值与子类型兼容。",
  "6699": "进行类型检查时，请考虑 “null” 和 “undefined”。",
  "6700": "检查是否有已声明但未在构造函数中设置的类属性。",
  "6701": "禁用在其 JSDoc 注释中包含 “@internal” 的发出声明。",
  "6702": "禁用在创建对象文字期间报告多余属性错误。",
  "6703": "在对缺少索引签名的对象编制索引时，抑制 “noImplicitAny” 错误。",
  "6704": "在不支持本机递归监视的平台上同步调用回调并更新目录观察程序的状态。",
  "6705": "为发出的 JavaScript 设置 JavaScript 语言版本并包含兼容的库声明。",
  "6706": "在 “moduleResolution” 进程期间使用的日志路径。",
  "6707": "指定 .tsbuildinfo 增量编译文件的路径。",
  "6709": "指定用于自动获取声明文件的选项。",
  "6710": "指定多个行为类似于 “./node_modules/@types” 的文件夹。",
  "6711": "指定要包含的类型包名称，而无需在源文件中引用。",
  "6712": "发出符合 ECMAScript 标准的类字段。",
  "6713": "启用详细日志记录。",
  "6714": "指定在缺少递归文件监视功能的系统上监视目录的方式。",
  "6715": "指定 TypeScript 监视模式的工作方式。",
  "6717": "要求索引签名中有未声明的属性以使用元素访问。",
  "6718": "指定仅用于类型的导入的发出/检查行为。",
  "6719": "导出时需要足够的注释，以便其他工具可以轻松生成声明文件。",
  "6720": "内置迭代器实例化时，“TReturn”类型为“undefined”而不是“any”。",
  "6721": "不允许不属于 ECMAScript 的运行时构造。",
  "6803": "将 catch 子句变量默认为 “unknown” 而不是 “any”。",
  "6804": "不要转换或省略任何未标记为仅类型的导入或导出，确保它们是根据“模块”设置以输出文件格式编写的。",
  "6805": "禁用完整类型检查（仅报告关键分析和发出错误）。",
  "6806": "检查副作用导入。",
  "6807": "可以简化此操作。此班次与 `{0} {1} {2}` 相同。",
  "6808": "启用 lib 替换。",
  "6900": "以下其中一个:",
  "6901": "一个或更多:",
  "6902": "类型:",
  "6903": "默认值:",
  "6904": "module === \"system\" 或 esModuleInterop",
  "6905": "\"false\"，除非设置了 \"strict\"",
  "6906": "\"false\"，除非设置了 \"composite\"",
  "6907": "`[\"node_modules\"、\"bower_components\"、\"jspm_packages\"]`，以及 \"outDir\" 的值(如果指定)。",
  "6908": "如果指定了 \"files\"，则为 \"[]\"，否则为\"[\"**/*\"]5D;\"",
  "6909": "如果为 \"composite\"，则为 \"true\"，否则为 \"false\"",
  "6911": "从输入文件列表计算",
  "6912": "平台特定",
  "6913": "你可以在 {0} 了解编译器选项的所有内容",
  "6914": "包括 --watch，-w 将开始监视当前项目的文件更改。设置后，可以使用以下内容配置监视模式:",
  "6915": "使用 --build，-b 将使 tsc 的行为更像生成业务流程协调程序，而非编译器。这可用于触发生成复合项目，你可以在 {0} 详细了解这些项目",
  "6916": "常见命令",
  "6917": "所有编译器选项",
  "6918": "监视选项",
  "6919": "生成选项",
  "6920": "常见编译器选项",
  "6921": "命令行标记",
  "6922": "tsc: TypeScript 编译器",
  "6923": "编译当前项目(工作目录中的 tsconfig.json。)",
  "6924": "忽略 tsconfig.json，使用默认编译器选项编译指定文件。",
  "6925": "在工作目录中生成复合项目。",
  "6926": "使用工作目录中的建议设置创建 tsconfig.json。",
  "6927": "编译位于指定路径的 TypeScript 项目。",
  "6928": "此信息的扩展版本，显示所有可能的编译器选项",
  "6929": "使用其他设置编译当前项目。",
  "6930": "对于 ES2022 及更高版本为 `true`，包括 ESNext。",
  "6931": "解析模块时要搜索的文件名后缀列表。",
  "7005": "变量“{0}”隐式具有“{1}”类型。",
  "7006": "参数“{0}”隐式具有“{1}”类型。",
  "7008": "成员“{0}”隐式包含类型“{1}”。",
  "7009": "其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型。",
  "7010": "缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。",
  "7011": "缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。",
  "7012": "此重载隐式返回类型“{0}”，因为它缺少返回类型批注。",
  "7013": "缺少返回类型批注的构造签名隐式具有返回类型 \"any\"。",
  "7014": "缺少返回类型注释的函数类型隐式具有 \"{0}\" 返回类型。",
  "7015": "元素隐式具有 \"any\" 类型，因为索引表达式的类型不为 \"number\"。",
  "7016": "无法找到模块“{0}”的声明文件。“{1}”隐式拥有 \"any\" 类型。",
  "7017": "元素隐式具有 \"any\" 类型，因为类型“{0}”没有索引签名。",
  "7018": "对象字面量的属性“{0}”隐式含有“{1}”类型。",
  "7019": "Rest 参数“{0}”隐式具有 \"any[]\" 类型。",
  "7020": "缺少返回类型批注的调用签名隐式具有返回类型 \"any\"。",
  "7022": "“{0}”隐式具有类型 \"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。",
  "7023": "由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "7024": "由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "7025": "生成器隐式具有 yield 类型 ‘{0}’。请考虑提供一个返回类型注释。",
  "7026": "JSX 元素隐式具有类型 \"any\"，因为不存在接口 \"JSX.{0}\"。",
  "7027": "检测到无法访问的代码。",
  "7028": "未使用的标签。",
  "7029": "switch 语句中的 Fallthrough 情况。",
  "7030": "并非所有代码路径都返回值。",
  "7031": "绑定元素“{0}”隐式具有“{1}”类型。",
  "7032": "属性“{0}”隐式具有类型 \"any\"，因为其 set 访问器缺少参数类型批注。",
  "7033": "属性“{0}”隐式具有类型 \"any\"，因为其 get 访问器缺少返回类型批注。",
  "7034": "变量“{0}”在某些无法确定其类型的位置处隐式具有类型“{1}”。",
  "7035": "尝试使用 `npm i --save-dev @types/{1}` (如果存在)，或者添加一个包含 `declare module '{0}';` 的新声明(.d.ts)文件",
  "7036": "动态导入的说明符类型必须是 \"string\"，但此处类型是 \"{0}\"。",
  "7037": "通过为所有导入创建命名空间对象来启用 CommonJS 和 ES 模块之间的发出互操作性。表示 \"allowSyntheticDefaultImports\"。",
  "7038": "此导入产生的类型。无法调用或构造命名空间样式的导入，这类导入将在运行时导致失败。请考虑改为使用默认导入或此处需要的导入。",
  "7039": "映射的对象类型隐式地含有 \"any\" 模板类型。",
  "7040": "如果“{0}”包实际上公开此模块，请考虑发送拉取请求以修正“https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}”",
  "7041": "包含箭头函数捕获 \"this\" 的全局值。",
  "7042": "模块 \"{0}\" 已解析为 \"{1}\"，但未使用 \"--resolveJsonModule\"。",
  "7043": "变量 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7044": "参数 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7045": "成员 \"{0}\" 隐式具有 \"{1}\" 类型，但可以从用法中推断出更好的类型。",
  "7046": "变量 \"{0}\" 在某些位置隐式具有类型 \"{1}\"，但可以从使用情况推断出更好的类型。",
  "7047": "Rest 参数 \"{0}\" 隐式具有 \"any[]\" 类型，但可从用法中推断出更好的类型。",
  "7048": "属性 \"{0}\" 隐式具有类型 \"any\"，但可从用法为其 get 访问器推断出更好类型。",
  "7049": "属性 \"{0}\" 隐式具有类型 \"any\"，但可从用法为其 set 访问器推断出更好的类型。",
  "7050": "\"{0}\" 隐式具有 \"{1}\" 返回类型，但可以从用法中推断出更好的类型。",
  "7051": "参数具有名称，但不具有类型。你是想使用 \"{0}: {1}\" 吗?",
  "7052": "元素隐式具有 \"any\" 类型，因为类型 \"{0}\" 没有索引签名。你是想调用 \"{1}\" 吗?",
  "7053": "元素隐式具有 \"any\" 类型，因为类型为 \"{0}\" 的表达式不能用于索引类型 \"{1}\"。",
  "7054": "在类型 \"{1}\" 上找不到具有类型为 \"{0}\" 的参数的索引签名。",
  "7055": "缺少返回类型批注的 \"{0}\" 隐式具有 \"{1}\" 产出类型。",
  "7056": "此节点的推断类型超出编译器将序列化的最大长度。需要显式类型注释。",
  "7057": "\"yield\" 表达式隐式导致 \"any\" 类型，因为它的包含生成器缺少返回类型批注。",
  "7058": "如果“{0}”包实际公开了此模块，请尝试添加包含 `declare module‘{1}';` 的新声明(.d.ts)文件",
  "7059": "此语法保留在扩展名为 .mts 或 .cts 的文件中。请改用 `as` 表达式。",
  "7060": "此语法保留在扩展名为 .mts 或 .cts 的文件中。请添加尾随逗号或显式约束。",
  "7061": "映射的类型可能不声明属性或方法。",
  "8000": "无法重命名此元素。",
  "8001": "不能重命名标准 TypeScript 库中定义的元素。",
  "8002": "\"import ... =\" 只能在 TypeScript 文件中使用。",
  "8003": "\"export =\" 只能在 TypeScript 文件中使用。",
  "8004": "类型参数声明只能在 TypeScript 文件中使用。",
  "8005": "\"implements\" 子句只能在 TypeScript 文件中使用。",
  "8006": "\"{0}\" 声明只能在 TypeScript 文件中使用。",
  "8008": "类型别名只能在 TypeScript 文件中使用。",
  "8009": "\"{0}\" 修饰符只能在 TypeScript 文件中使用。",
  "8010": "类型注释只能在 TypeScript 文件中使用。",
  "8011": "类型参数只能在 TypeScript 文件中使用。",
  "8012": "参数修饰符只能在 TypeScript 文件中使用。",
  "8013": "非 null 断言只能在 TypeScript 文件中使用。",
  "8016": "类型断言表达式只能在 TypeScript 文件中使用。",
  "8017": "签名声明只能在 TypeScript 文件中使用。",
  "8019": ".js 文件中的报表出错。",
  "8020": "JSDoc 类型只能在文档注释内部使用。",
  "8021": "JSDoc \"@typedef\" 标记应具有类型注释，或其后跟有 \"@property\" 或 \"@member\" 标记。",
  "8022": "JSDoc \"@{0}\" 未附加到类。",
  "8023": "JSDoc \"@{0} {1}\" 不匹配 \"extends {2}\" 子句。",
  "8024": "JSDoc \"@param\" 标记具有名称 \"{0}\"，但不存在具有该名称的参数。",
  "8025": "类声明不能有多个 “@augments” 或 “@extends” 标记。",
  "8026": "应为 {0} 类型参数；请为这些参数添加 \"@extends\" 标记。",
  "8027": "应为 {0}-{1} 类型参数；请为这些参数添加 \"@extends\" 标记。",
  "8028": "JSDoc \"...\" 可能仅出现在签名的最后一个参数中。",
  "8029": "JSDoc \"@param\" 标记的名称为“{0}”，但该名称没有参数。如果它为数组类型，将匹配 \"arguments\"。",
  "8030": "函数声明的类型必须与函数的签名匹配。",
  "8031": "不能通过全局导入对模块进行重命名。",
  "8032": "不允许使用限定名 \"{0}\"，因为没有前导 \"@param {object} {1}\"。",
  "8033": "JSDoc \"@typedef\" 注释不能包含多个 \"@type\" 标记。",
  "8034": "第一次在此处指定了标记。",
  "8035": "不能重命名已在 “node_modules” 文件夹中定义的元素。",
  "8036": "不能重命名已在另一个 “node_modules” 文件夹中定义的元素。",
  "8037": "类型满意度表达式只能在 TypeScript 文件中使用。",
  "8038": "如果修饰器也出现在“导出”之前，则它们可能不会出现在“export”或“export default”之后。",
  "8039": "JSDoc“@template”标记不能跟在“@typedef”、“@callback”或“@overload”标记后面",
  "9005": "此文件的声明发出要求使用专用名称 \"{0}\"。显式类型注释可能取消阻止声明发出。",
  "9006": "此文件的声明发出要求使用模块 \"{1}\" 中的专用名称 \"{0}\"。显式类型注释可能取消阻止声明发出。",
  "9007": "函数必须具有带有 --isolatedDeclarations 的显式返回类型注释。",
  "9008": "方法必须具有带有 --isolatedDeclarations 的显式返回类型注释。",
  "9009": "至少一个访问器必须具有带有 --isolatedDeclarations 的显式类型注释。",
  "9010": "变量必须具有带有 --isolatedDeclarations 的显式类型注释。",
  "9011": "参数必须具有带有 --isolatedDeclarations 的显式类型注释。",
  "9012": "属性必须具有带有 --isolatedDeclarations 的显式类型注释。",
  "9013": "无法使用 --isolatedDeclarations 推断表达式类型。",
  "9014": "计算属性必须是数字或字符串文本、变量或带 --isolatedDeclarations 的虚线表达式。",
  "9015": "无法使用 --isolatedDeclarations 推断包含传播赋值的对象。",
  "9016": "无法使用 --isolatedDeclarations 推断包含速记属性的对象。",
  "9017": "只能使用 --isolatedDeclarations 推断常量数组。",
  "9018": "无法使用 --isolatedDeclarations 推断具有分布元素的数组。",
  "9019": "绑定元素不能直接使用 --isolatedDeclarations 导出。",
  "9020": "枚举成员初始值设定项必须可计算，而不引用具有 --isolatedDeclarations 的外部符号。",
  "9021": "Extends 子句不能包含具有 --isolatedDeclarations 的表达式。",
  "9022": "--isolatedDeclarations 不支持从类表达式推理。",
  "9023": "--isolatedDeclarations 不支持将属性分配给不声明它们的函数。为分配给此函数的属性添加显式声明。",
  "9025": "为此参数发出的声明要求将未定义隐式添加到其类型。--isolatedDeclarations 不支持此功能。",
  "9026": "为此文件发出的声明需要保留此导入以进行扩充。--isolatedDeclarations 不支持此功能。",
  "9027": "向变量 {0} 添加类型注释。",
  "9028": "向参数 {0} 添加类型注释。",
  "9029": "向属性 {0} 添加类型注释。",
  "9030": "将返回类型添加到函数表达式。",
  "9031": "将返回类型添加到函数声明。",
  "9032": "将返回类型添加到 get 访问器声明。",
  "9033": "将类型添加到 set 访问器声明的参数。",
  "9034": "向方法添加返回类型",
  "9035": "将 satisfies 和类型断言添加到此表达式 (satisfies T as T) 以使类型显式。",
  "9036": "将默认导出中的表达式移动到变量，并向其添加类型注释。",
  "9037": "无法使用 --isolatedDeclarations 推断默认导出。",
  "9038": "不能使用 --isolatedDeclarations 推断类或对象文本上的计算属性名称。",
  "9039": "包含专用名称“{0}”的类型不能与 --isolatedDeclarations 一起使用。",
  "17000": "只能为 JSX 属性分配非空“表达式”。",
  "17001": "JSX 元素不能具有多个名称相同的特性。",
  "17002": "“{0}”预期的相应 JSX 结束标记。",
  "17004": "无法使用 JSX，除非提供了 \"--jsx\" 标志。",
  "17005": "当构造函数的类扩展 \"null\" 时，它不能包含 \"super\" 调用。",
  "17006": "乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。",
  "17007": "乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。",
  "17008": "JSX 元素“{0}”没有相应的结束标记。",
  "17009": "访问派生类的构造函数中的 \"this\" 前，必须调用 \"super\"。",
  "17010": "未知类型获取选项“{0}”。",
  "17011": "访问派生类构造函数中的 \"super\" 属性前，必须调用 \"super\"。",
  "17012": "“{0}”不是关键字“{1}”的有效元属性。是否是指“{2}”?",
  "17013": "元属性“{0}”只能在函数声明、函数表达式或构造函数的主体中使用。",
  "17014": "JSX 片段没有相应的结束标记。",
  "17015": "预期的 JSX 片段的相应结束标记。",
  "17016": "必须提供 \"jsxFragmentFactory\" 编译器选项才能将 JSX 片段与 \"jsxFactory\" 编译器选项一起使用。",
  "17017": "将 @jsx 杂注与 JSX 片段一起使用时，需要使用 @jsxFrag 杂注。",
  "17018": "未知的类型获取选项 \"{0}\"。你是想使用 \"{1}\" 吗?",
  "17019": "类型末尾的“{0}”不是有效的 TypeScript 语法。是否要写入“{1}”?",
  "17020": "类型开头的“{0}”不是有效的 TypeScript 语法。是否要写入“{1}”?",
  "17021": "Unicode 转义序列不能显示在此处。",
  "18000": "解析配置时检测到循环: {0}",
  "18002": "配置文件“{0}”中的 \"files\" 列表为空。",
  "18003": "在配置文件“{0}”中找不到任何输入。指定的 \"include\" 路径为“{1}”，\"exclude\" 路径为“{2}”。",
  "18004": "速记属性 \"{0}\" 的范围内不存在任何值。请声明一个值或提供一个初始值设定项。",
  "18006": "类不能具有名为 \"constructor\" 的字段。",
  "18007": "JSX 表达式不能使用逗号运算符。你是想写入数组吗?",
  "18009": "不能将专用标识符用作参数。",
  "18010": "可访问性修饰符不能与专用标识符一起使用。",
  "18011": "\"delete\" 运算符的操作数不能是专用标识符。",
  "18012": "\"#constructor\" 是保留字。",
  "18013": "属性 \"{0}\" 在类 \"{1}\" 外部不可访问，因为它具有专用标识符。",
  "18014": "无法在此类中的类型 \"{1}\" 上访问属性 \"{0}\"，因为具有相同拼写的另一个专用标识符隐藏了它。",
  "18015": "类型 \"{1}\" 中的属性 \"{0}\" 引用了不能从类型 \"{2}\" 内访问的其他成员。",
  "18016": "不允许在类主体之外使用专用标识符。",
  "18017": "在此处定义了“{0}”的阴影声明",
  "18018": "你可能打算使用的 \"{0}\" 的声明在此处定义",
  "18019": "“{0}”修饰符不能与专用标识符一起使用。",
  "18024": "不能用专用标识符命名枚举成员。",
  "18026": "\"#!\" 只能用在文件的开头。",
  "18027": "当发出专用标识符下层时，编译器会预留名称“{0}”。",
  "18028": "专用标识符仅在面向 ECMAScript 2015 和更高版本时可用。",
  "18029": "不允许在变量声明中使用专用标识符。",
  "18030": "可选链不能包含专用标识符。",
  "18031": "由于属性“{1}”在某些要素中具有存在冲突的类型，因此已将交集“{0}”缩减为“绝不”。",
  "18032": "由于属性“{1}”存在于多个要素中，但在某些要素中是专用属性，因此已将交集“{0}”缩减为“绝不”。",
  "18033": "根据计算枚举成员值的要求，类型“{0}”不能分配给类型“{1}”。",
  "18034": "当指定使用 \"jsxFactory\" 编译器选项面向 \"react\" JSX 发出时，指定要使用的 JSX 片段工厂函数，例如 \"Fragment\"。",
  "18035": "\"jsxFragmentFactory\" 的值无效。“{0}”不是有效的标识符或限定名称。",
  "18036": "类修饰器不能与静态专用标识符一起使用。请考虑删除实验性修饰器。",
  "18037": "\"await\" 表达式不能在类静态块内使用。",
  "18038": "\"for await\" 循环不能在类静态块内使用。",
  "18039": "“{0}”的使用无效。它不能在类静态块内使用。",
  "18041": "不能在类静态块内使用 “return” 语句。",
  "18042": "“{0}”是一种类型，无法在 JavaScript 文件中导入。请在 JSDoc 类型批注中使用“{1}”。",
  "18043": "类型不能出现在 JavaScript 文件的导出声明中。",
  "18044": "“{0}”自动导出到此处。",
  "18045": "只有在面向 ECMAScript 2015 及更高版本时，才可使用带有 \"accessor\" 修饰符的属性。",
  "18046": "“{0}”的类型为“未知”。",
  "18047": "“{0}”可能为 “null”。",
  "18048": "“{0}”可能为“未定义”。",
  "18049": "{0}可能为 “null” 或“未定义”。",
  "18050": "此处不能使用值“{0}”。",
  "18051": "无法为编译器选项“{0}”提供空字符串。",
  "18053": "其类型“{0}”不是有效的 JSX 元素类型。",
  "18054": "\"await using\" 语句不能在类静态块内使用。",
  "18055": "“{0}”具有字符串类型，但在启用 \"isolatedModules\" 时必须具有语法上可识别的字符串语法。",
  "18056": "启用“isolatedModules”时，非文本数值成员之后的枚举成员必须具有初始值设定项。",
  "18057": "当“--module”标志设置为“es2015”或“es2020”时，不支持字符串文本导入和导出名称。",
  "18058": "延迟导入中不允许使用默认导入。",
  "18059": "延迟导入中不允许使用命名导入。",
  "18060": "仅当 ‘--module’ 标志设置为 ‘esnext’ 或 ‘preserve’ 时，才支持延迟导入。",
  "18061": "“{0}”不是关键字 ‘import’ 的有效元属性。你是说 ‘meta’ 还是 ‘defer’?",
  "69010": "module === 'AMD' 或 'UMD' 或 'System' 或 'ES6'，然后 'Classic'， 否则为 'Node'",
  "80001": "文件是 CommonJS 模块; 它可能会转换为 ES 模块。",
  "80002": "此构造函数可能会转换为类声明。",
  "80003": "导入可能会转换为默认导入。",
  "80004": "JSDoc 类型可能会移到 TypeScript 类型。",
  "80005": "可将 \"require\" 调用转换为 import 语句。",
  "80006": "可将此转换为异步函数。",
  "80007": "\"await\" 对此表达式的类型没有影响。",
  "80008": "绝对值大于或等于 2^53 的数值文本过大，无法用整数准确表示。",
  "80009": "JSDoc typedef 可以转换为 TypeScript 类型。",
  "80010": "JSDoc typedef 可以转换为 TypeScript 类型。",
  "90001": "添加缺失的 \"super()\" 调用",
  "90002": "在构造函数中，使 \"super()\" 调用第一个语句",
  "90003": "将 \"extends\" 改为 \"implements\"",
  "90004": "为 \"{0}\" 删除未使用的声明",
  "90005": "从“{0}”删除导入",
  "90006": "实现接口“{0}”",
  "90007": "实现已继承的抽象类",
  "90008": "将“{0}.”添加到未解析的变量",
  "90010": "删除变量语句",
  "90011": "删除模板标记",
  "90012": "删除类型参数",
  "90013": "从“{1}”导入“{0}”",
  "90014": "将“{0}”更改为“{1}”",
  "90016": "声明属性“{0}”",
  "90017": "为属性“{0}”添加索引签名",
  "90018": "禁用检查此文件",
  "90019": "忽略此错误信息",
  "90020": "初始化构造函数中的属性“{0}”",
  "90021": "初始化静态属性“{0}”",
  "90022": "将拼写更改为“{0}”",
  "90023": "声明方法“{0}”",
  "90024": "声明静态方法“{0}”",
  "90025": "带下划线的前缀“{0}”",
  "90026": "重写为索引访问类型“{0}”",
  "90027": "声明静态属性“{0}”",
  "90028": "调用修饰器表达式",
  "90029": "将异步修饰符添加到包含函数",
  "90030": "将 \"infer {0}\" 替换为 \"unknown\"",
  "90031": "将所有未使用的 \"infer\" 替换为 \"unknown\"",
  "90034": "添加参数名称",
  "90035": "声明专用属性“{0}”",
  "90036": "将 \"{0}\" 替换为 \"Promise<{1}>\"",
  "90037": "修复所有错误的异步函数返回类型",
  "90038": "声明私有方法 \"{0}\"",
  "90039": "删除未使用的解构声明",
  "90041": "为“{0}”删除未使用的声明",
  "90053": "声明名为 \"{0}\" 的专用字段。",
  "90054": "包含由“{0}”引用的类型的导入",
  "90055": "从“{0}”中删除导入声明中的“type”",
  "90056": "从“{1}”中删除“{0}”导入中的“type”",
  "90057": "从“{0}”添加导入",
  "90058": "从“{0}”更新导入",
  "90059": "从模块“{1}”导出“{0}”",
  "90060": "导出所有引用的局部变量",
  "90061": "更新“{0}”的修饰符",
  "90062": "添加类型为“{0}”的注释",
  "90063": "添加返回类型“{0}”",
  "90064": "将基类提取到变量",
  "90065": "将默认导出提取到变量",
  "90066": "将绑定表达式提取到变量",
  "90067": "添加所有缺少的类型注释",
  "90068": "使用“{0}”添加 satisfies 和内联类型断言",
  "90069": "提取到变量并替换为“{0} 为 typeof {0}”",
  "90070": "将数组文字标记为常量",
  "90071": "注释命名空间中属性 expando 函数的类型",
  "95001": "将函数转换为 ES2015 类",
  "95003": "将“{0}”转换为 {0} 中的 {1}",
  "95004": "提取到 {1} 中的 {0}",
  "95005": "提取函数",
  "95006": "提取常数",
  "95007": "提取到封闭范围中的 {0}",
  "95008": "提取到 {1} 范围中的 {0}",
  "95009": "通过 JSDoc 类型批注",
  "95011": "根据使用情况推断“{0}”的类型",
  "95012": "根据使用情况推断参数类型",
  "95013": "转换为默认导入",
  "95014": "安装“{0}”",
  "95015": "用“{0}”替换导入。",
  "95016": "使用综合的“默认”成员。",
  "95017": "转换为 ES 模块",
  "95018": "向属性“{0}”添加 \"undefined\" 类型",
  "95019": "向属性“{0}”添加初始值设定项",
  "95020": "向属性“{0}”添加明确的赋值断言",
  "95021": "将所有类型文本转换为映射类型",
  "95022": "添加所有缺少的成员",
  "95023": "从使用情况推导所有类型",
  "95024": "删除未使用的所有声明",
  "95025": "尽可能在所有未使用的声明前添加前缀 \"_\"",
  "95026": "修复检测到的所有拼写错误",
  "95027": "将初始化表达式添加到未初始化的所有属性",
  "95028": "将明确赋值断言添加到未初始化的所有属性",
  "95029": "将未定义的类型添加到未初始化的所有属性",
  "95030": "将所有 JSDoc 样式类型都更改为 TypeScript",
  "95031": "将所有 JSDoc 样式类型都更改为 TypeScript (并将 \"| undefined\" 添加到可以为 null 的类型)",
  "95032": "实现未实现的所有接口",
  "95033": "安装缺少的所有类型包",
  "95034": "全部重写为索引访问类型",
  "95035": "全部转换为默认导入",
  "95036": "让所有 \"super()\" 调用成为构造函数中的第一个语句",
  "95037": "将限定符添加到匹配成员名称的所有未解析变量",
  "95038": "将所有扩展接口都更改为 \"implements\"",
  "95039": "添加所有缺失的 super() 调用",
  "95040": "实现继承的所有抽象类",
  "95041": "添加所有缺失的 \"async\" 修饰符",
  "95042": "将 \"@ts-ignore\" 添加到所有错误消息",
  "95043": "使用 JSDoc 中的类型批注所有内容",
  "95044": "将 \"()\" 添加到所有未调用的修饰器",
  "95045": "将所有构造函数都转换为类",
  "95046": "生成 \"get\" 和 \"set\" 访问器",
  "95047": "将 \"require\" 转换为 \"import\"",
  "95048": "将所有 \"require\" 转换为 \"import\"",
  "95049": "移动到新的文件",
  "95050": "删除无法访问的代码",
  "95051": "删除所有无法访问的代码",
  "95052": "添加缺少的 \"typeof\"",
  "95053": "删除未使用的标签",
  "95054": "删除所有未使用的标签",
  "95055": "将“{0}”转换为映射对象类型",
  "95056": "将命名空间导入转换为命名导入",
  "95057": "将命名导入转换为命名空间导入",
  "95058": "添加或删除箭头函数中的大括号",
  "95059": "向箭头函数添加大括号",
  "95060": "从箭头函数中删除大括号",
  "95061": "将默认导出转换为命名导出",
  "95062": "将命名导出转换为默认导出",
  "95063": "添加缺少的枚举成员 \"{0}\"",
  "95064": "添加所有缺少的导入",
  "95065": "转换为异步函数",
  "95066": "全部转换为异步函数",
  "95067": "添加缺失的调用括号",
  "95068": "添加所有缺失的调用括号",
  "95069": "为非重叠类型添加 \"unknown\" 转换",
  "95070": "将 \"unknown\" 添加到非重叠类型的所有转换",
  "95071": "将缺少的 \"new\" 运算符添加到调用",
  "95072": "将缺少的 \"new\" 运算符添加到所有调用",
  "95073": "为没有名称的所有参数添加名称",
  "95074": "在配置文件中启用 \"experimentalDecorators\" 选项",
  "95075": "将参数转换为析构对象",
  "95077": "提取类型",
  "95078": "提取到类型别名",
  "95079": "提取到类型引用",
  "95080": "从用法中推断出 \"{0}\" 的 \"this\" 类型",
  "95081": "将 \"const\" 添加到未解析的变量",
  "95082": "将 \"const\" 添加到所有未解析变量",
  "95083": "添加 \"await\"",
  "95084": "将 \"await\" 添加到 \"{0}\" 的初始值设定项",
  "95085": "修复可能缺少 \"await\" 的所有表达式",
  "95086": "删除不必要的 \"await\"",
  "95087": "删除 \"await\" 的所有不必要的使用",
  "95088": "在配置文件中启用 \"--jsx\" 标志",
  "95089": "将 \"await\" 添加到初始值设定项",
  "95090": "提取到接口",
  "95091": "转换为 BigInt 数字字面量",
  "95092": "全部转换为 BigInt 数字字面量",
  "95093": "将 \"const\" 转换为 \"let\"",
  "95094": "使用 \"declare\" 前缀",
  "95095": "使用 \"declare\" 作为所有错误的属性声明的前缀",
  "95096": "转换为模板字符串",
  "95097": "添加 \"export {}\"，将此文件变为模块",
  "95098": "将配置文件中的 \"target\" 选项设置为 \"{0}\"",
  "95099": "将配置文件中的 \"module\" 选项设置为 \"{0}\"",
  "95100": "将无效字符转换为其 HTML 实体代码",
  "95101": "将所有无效字符转换为 HTML 实体代码",
  "95102": "将所有 'const' 转换为 'let'",
  "95105": "将函数表达式 \"{0}\" 转换为箭头函数",
  "95106": "将函数声明“{0}”转换为箭头函数",
  "95107": "修复所有 implicit-'this' 错误",
  "95108": "包装表达式容器中的无效字符",
  "95109": "包装表达式容器中的所有无效字符",
  "95110": "请访问 https://aka.ms/tsconfig，了解有关此文件的详细信息",
  "95111": "添加 return 语句",
  "95112": "从箭头函数主体中删除大括号",
  "95113": "用括号括起以下应为对象字面量的内容",
  "95114": "添加所有缺少的 return 语句",
  "95115": "从所有带有相关问题的箭头函数主体中删除大括号",
  "95116": "用括号括起所有对象字面量",
  "95117": "将已标记的元组元素修饰符移至标签",
  "95118": "将重载列表转换为单一签名",
  "95119": "为所有重写属性生成 \"get\" 和 \"set\" 访问器",
  "95120": "包装在 JSX 片段中",
  "95121": "将所有没有父级的 JSX 包装在 JSX 片段中",
  "95122": "转换箭头函数或函数表达式",
  "95123": "转换为异步函数",
  "95124": "转换为指定函数",
  "95125": "转换为箭头函数",
  "95126": "删除括号",
  "95127": "找不到包含箭头函数",
  "95128": "包含函数不是箭头函数",
  "95129": "找不到 export 语句",
  "95130": "此文件已具有默认导出",
  "95131": "找不到 import 子句",
  "95132": "找不到命名空间导入或已命名的导入",
  "95133": "所选内容不是有效的类型节点",
  "95134": "无法从该类型节点中提取任何类型",
  "95135": "找不到要为其生成访问器的属性",
  "95136": "名称无效",
  "95137": "只能转换带修饰符的属性",
  "95138": "将每个误用的“{0}”切换到“{1}”",
  "95139": "转换为可选链表达式",
  "95140": "找不到可转换的访问表达式",
  "95141": "找不到匹配的访问表达式",
  "95142": "仅可转换逻辑 AND 访问链",
  "95143": "将 \"void\" 添加到已解析但没有值的 Promise",
  "95144": "将 \"void\" 添加到所有已解析但没有值的 Promise",
  "95145": "对“{0}”使用元素访问",
  "95146": "对所有未声明的属性使用元素访问。",
  "95147": "删除所有未使用的导入",
  "95148": "推断函数返回类型",
  "95149": "必须从函数中推断返回类型",
  "95150": "无法确定函数返回类型",
  "95151": "无法转换为箭头函数",
  "95152": "无法转换为命名函数",
  "95153": "无法转换为匿名函数",
  "95154": "只能转换字符串串联和字符串文本",
  "95155": "所选内容不是有效的语句",
  "95156": "添加缺少的函数声明 \"{0}\"",
  "95157": "添加所有缺少的函数声明",
  "95158": "方法未实现。",
  "95159": "未实现函数。",
  "95160": "添加 \"override\" 修饰符",
  "95161": "删除 \"override\" 修饰符",
  "95162": "添加所有缺失的 \"override\" 修饰符",
  "95163": "删除所有不必要的 \"override\" 修饰符",
  "95164": "只能转换已命名的导出",
  "95165": "添加缺少的属性",
  "95166": "添加所有缺少的属性",
  "95167": "添加缺少的属性",
  "95168": "添加所有缺少的属性",
  "95169": "将 “undefined” 添加到可选属性类型",
  "95170": "将命名导入转换为默认导入",
  "95171": "删除未使用的 “@param” 标记“{0}”",
  "95172": "删除所有未使用的 “@param” 标记",
  "95173": "将 “@param” 标记名称“{0}”重命名为“{1}”",
  "95174": "使用 `{0}`",
  "95175": "在所有条件下使用 `Number.isNaN`。",
  "95176": "将 typedef 转换为 TypeScript 类型。",
  "95177": "将所有 typedef 转换为 TypeScript 类型。",
  "95178": "移动到文件",
  "95179": "无法移动到文件，所选文件无效",
  "95180": "使用 \"import type\"",
  "95181": "使用 \"type {0}\"",
  "95182": "使用仅类型导入修复所有问题",
  "95183": "无法将语句移动到所选文件",
  "95184": "内联变量",
  "95185": "找不到要内联的变量。",
  "95186": "具有多个声明的变量不能内联。",
  "95187": "为对象成员完成“{0}”添加缺少的逗号。",
  "95188": "将缺少的参数添加到“{0}”",
  "95189": "将缺少的参数添加到“{0}”",
  "95190": "添加所有缺少的参数",
  "95191": "将可选参数添加到“{0}”",
  "95192": "将可选参数添加到“{0}”",
  "95193": "添加所有可选参数",
  "95194": "用括号括起来",
  "95195": "将所有无效的修饰器表达式括在括号中",
  "95196": "添加 \"resolution-mode\" 导入属性",
  "95197": "向所有需要 \"resolution-mode\" 导入属性的仅类型导入添加该属性"
}